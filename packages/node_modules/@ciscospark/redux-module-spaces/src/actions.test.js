/* eslint-disable max-nested-callbacks */
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

import {initialState} from '.';
import * as actions from '.';

let avatar, file, mockSpark, person, space, spaces, store, team, user1, user2;

describe(`redux-module-space actions `, () => {
  beforeEach(() => {
    store = mockStore(initialState);

    person = {
      avatar: `https://avatar-url`
    };

    avatar = {
      objectType: `content`,
      files: {
        items: [
          {
            objectType: `file`,
            url: `https://fileUrl`,
            fileSize: 56520,
            mimeType: `image/png`,
            scr: {}
          }
        ]
      },
      contentCategory: `images`
    };

    team = {
      displayName: `Test Team`,
      color: `#C589C5`,
      generalConversationUuid: `spaceId`,
      id: `teamId`,
      archived: false
    };

    user1 = {
      entryEmail: `person1@email.com`,
      displayName: `Person 1`,
      emailAddress: `person1@email.com`,
      objectType: `person`,
      type: `PERSON`,
      id: `other-userid`,
      orgId: `12345678-1234-1234-1234-123456789000`
    };

    user2 = {
      entryEmail: `person2@email.com`,
      displayName: `Person 2`,
      emailAddress: `person2@email.com`,
      objectType: `person`,
      type: `PERSON`,
      id: `this-user-id`,
      orgId: `12345678-1234-1234-1234-123456789000`
    };

    space = {
      participants: [user1, user2],
      lastReadableActivityDate: `2017-06-07T15:13:56.326Z`,
      displayName: `Space 1`,
      lastSeenActivityDate: `2017-06-07T15:13:34.505Z`,
      published: `2016-02-29T17:49:17.029Z`,
      url: `https://converstaionUrl`,
      activities: {
        items: [{
          published: `2017-06-07T15:13:56.326Z`,
          url: `https://activityUrl`,
          target: {
            id: `conversationId`,
            objectType: `conversation`,
            url: `https://converstaionUrl`,
            participants: {
              items: []
            },
            activities: {
              items: []
            },
            tags: []
          },
          encryptionKeyUrl: `https://encryptionKeyUrl`,
          actor: user1,
          objectType: `activity`,
          id: `activityId`,
          verb: `post`,
          object: {
            objectType: `comment`,
            displayName: `Great work team!!!`
          }
        }]
      },
      tags: [
        `MUTED`,
        `FAVORITE`,
        `LOCKED`,
        `TEAM`,
        `JOINED`,
        `MESSAGE_NOTIFICATIONS_OFF`,
        `MENTION_NOTIFICATIONS_ON`
      ],
      avatar,
      type: `group`,
      id: `spaceId`,
      team,
      conversationWebUrl: `https://conversationWebUrl`
    };

    spaces = [
      space,
      space,
      space
    ];


    file = new Uint8Array();

    mockSpark = {
      internal: {
        device: {
          userId: `this-user-id`
        },
        conversation: {
          get: jest.fn(() => Promise.resolve(space)),
          download: jest.fn(() => Promise.resolve(file)),
          list: jest.fn(() => Promise.resolve(spaces))
        }
      },
      people: {
        get: jest.fn(() => Promise.resolve(person))
      }
    };

  });

  it(`has exported actions`, () => {
    expect(actions.initialFetchSpaces).toBeDefined();
    expect(actions.fetchSpaceAvatar).toBeDefined();
    expect(actions.fetchSpace).toBeDefined();
    expect(actions.removeSpace).toBeDefined();
    expect(actions.updateSpaceWithActivity).toBeDefined();
  });


  describe(`#initialFetchSpaces`, () => {
    it(`properly fetches spaces`, () => {
      store.dispatch(actions.initialFetchSpaces(mockSpark)).then(() => {
        expect(store.getActions()).toMatchSnapshot();
      });
    });
  });


  describe(`#fetchSpaceAvatar`, () => {
    it(`properly fetches direct space avatar`, () => {
      space.type = `direct`;
      Reflect.deleteProperty(space, `avatar`);
      store.dispatch(actions.fetchSpaceAvatar(mockSpark, space)).then(() => {
        expect(store.getActions()).toMatchSnapshot();
      });
    });

    it(`properly fetches group space avatar`, () => {
      store.dispatch(actions.fetchSpaceAvatar(mockSpark, space)).then(() => {
        expect(store.getActions()).toMatchSnapshot();
      });
    });

    it(`fail to fetch group space avatar when not available`, () => {
      space.type = `group`;
      Reflect.deleteProperty(space, `avatar`);
      store.dispatch(actions.fetchSpaceAvatar(mockSpark, space)).then(() => {
        expect(store.getActions()).toMatchSnapshot();
      });
    });
  });


  describe(`#fetchSpace`, () => {
    it(`properly fetches a space`, () => {
      store.dispatch(actions.fetchSpace(mockSpark, `spaceId`)).then(() => {
        expect(store.getActions()).toMatchSnapshot();
      });
    });
  });

  describe(`#removeSpace`, () => {
    it(`properly removes a space`, () => {
      store.dispatch(actions.removeSpace(`spaceId`));
      expect(store.getActions()).toMatchSnapshot();
    });
  });

});
