import {fromJS} from 'immutable';

export const initialState = fromJS({
  items: [],
  status: {
    isFetching: false
  }
});

export const UPDATE_SPACES_STATUS = `spaces/UPDATE_SPACES_STATUS`;
export const STORE_SPACES = `spaces/STORE_SPACES`;
export default function reducer(state = initialState, action) {
  switch (action.type) {
  case UPDATE_SPACES_STATUS:
    return state.mergeDeepIn([`status`], action.payload.status);

  case STORE_SPACES:
    // Not processing in any way for now. May want to filter in future
    return state.setIn([`status`, `isFetching`], false)
      .set(`items`, fromJS(action.payload.spaces));

  default:
    return state;
  }
}

function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces
    }
  };
}

function updateSpacesStatus(status) {
  return {
    type: UPDATE_SPACES_STATUS,
    payload: {
      status
    }
  };
}

export function fetchSpaces(sparkInstance) {
  return (dispatch) => {
    dispatch(updateSpacesStatus({isFetching: true}));
    return sparkInstance.conversation.list({
      lastViewableActivityOnly: true,
      participantsLimit: 10,
      conversationLimit: 9999
    }).then((items) => dispatch(storeSpaces(items)));
  };
}
