import {constructSpace} from './helpers';

export const STORE_SPACES = 'spaces/STORE_SPACES';
export const UPDATE_SPACES_STATUS = 'spaces/UPDATE_SPACES_STATUS';
export const UPDATE_SPACE_WITH_ACTIVITY = 'spaces/UPDATE_SPACE_WITH_ACTIVITY';
export const UPDATE_SPACE_READ = 'spaces/UPDATE_SPACE_READ';
export const REMOVE_SPACE = 'spaces/REMOVE_SPACE';
export const STORE_SPACE = 'spaces/STORE_SPACE';

const TAG_LOCKED = 'LOCKED';
const TAG_HIDDEN = 'HIDDEN';


export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}

/**
 * Updates the last seen date of a space
 * @param {String} spaceId
 * @param {String} lastSeenDate
 * @returns {Object}
 */
export function updateSpaceRead(spaceId, lastSeenDate) {
  return {
    type: UPDATE_SPACE_READ,
    payload: {
      lastSeenDate,
      spaceId
    }
  };
}


function updateSpacesStatus(status) {
  return {
    type: UPDATE_SPACES_STATUS,
    payload: {
      status
    }
  };
}


function storeSpace(space) {
  return {
    type: STORE_SPACE,
    payload: {
      space
    }
  };
}


function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces
    }
  };
}


function decryptSpace(space) {
  if (typeof space.decrypt === 'function') {
    return space.decrypt()
      .then((s) => Promise.resolve(s));
  }
  return Promise.resolve();
}

/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @returns {Function} thunk
 */

export function getSpaces(sparkInstance, options = {}) {
  const defaultOptions = {
    ackFilter: 'noack',
    uuidEntryFormat: true,
    personRefresh: true,
    latestActivity: '',
    isActive: true,
    lastViewableActivityOnly: true,
    participantAckFilter: 'all',
    // Only need 2 for One on One conversations
    participantsLimit: 2
  };

  const listOptions = Object.assign({}, defaultOptions, options);

  return (dispatch) => sparkInstance.internal.conversation
    .list(listOptions)
    .then((items) => {
      const spaces = {};
      const decryptPromises = [];

      dispatch(updateSpacesStatus({isDecrypting: true}));

      items.forEach((space) => {
        if (!space.tags.includes(TAG_HIDDEN)) {
          spaces[space.id] = constructSpace(space, listOptions.deferDecrypt);
          if (space.decrypt) {
            decryptPromises.push(decryptSpace(space)
              .then((decryptedSpace) => {
                if (decryptedSpace) {
                  const s = constructSpace(decryptedSpace, false);
                  dispatch(storeSpace(s));
                  return Promise.resolve(s);
                }
                return Promise.resolve();
              }));
          }
        }
      });

      Promise.all(decryptPromises)
        .then((s) => {
          dispatch(updateSpacesStatus({isDecrypting: false}));
          return Promise.resolve(s);
        });

      return dispatch(storeSpaces(spaces));
    });
}

/**
 * Fetches a list of spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options to pass to SDK
 * @returns {Function} thunk
 */

export function fetchSpaces(sparkInstance, options = {}) {
  return (dispatch) => {
    dispatch(updateSpacesStatus({isFetching: true}));
    return dispatch(getSpaces(sparkInstance, {
      conversationsLimit: 15,
      deferDecrypt: true,
      ...options
    }))
      .then(() => dispatch(getSpaces(sparkInstance, {
        conversationsLimit: 1000,
        ...options
      })))
      .then((spaces) => {
        dispatch(updateSpacesStatus({isFetching: false}));
        return Promise.resolve(spaces);
      });
  };
}

/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId) {
  return (dispatch) => sparkInstance.internal.conversation.get({
    id: spaceId
  }, {
    activitiesLimit: 25,
    participantAckFilter: 'all',
    includeParticipants: true
  }).then((space) => {
    const constructedSpace = constructSpace(space);
    dispatch(storeSpace(constructedSpace));
    return constructedSpace;
  });
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @param {Boolean} isReadable if the activity is a readable activity
 * @returns {Object} action
 */
export function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}
