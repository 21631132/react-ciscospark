export const STORE_SPACES = `spaces/STORE_SPACES`;
export const UPDATE_SPACES_STATUS = `spaces/UPDATE_SPACES_STATUS`;
export const UPDATE_SPACE_WITH_ACTIVITY = `spaces/UPDATE_SPACE_WITH_ACTIVITY`;
export const ACKNOWLEDGE_SPACE = `spaces/ACKNOWLEDGE_SPACE`;
export const REMOVE_SPACE = `spaces/REMOVE_SPACE`;
export const ADD_SPACE = `spaces/ADD_SPACE`;

const TAG_ONE_ON_ONE = `ONE_ON_ONE`;


export function updateSpacesStatus(status) {
  return {
    type: UPDATE_SPACES_STATUS,
    payload: {
      status
    }
  };
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @returns {Object} action
 */
export function updateSpaceWithActivity(activity, isSelf) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity,
    lastReadableActivityDate: activity.published
  };
  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }
  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}


export function acknowledgeSpace(activity) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  return {
    type: ACKNOWLEDGE_SPACE,
    payload: {
      space: {
        id: activity.target.id,
        lastSeenActivityDate: activity.published
      }
    }
  };
}


export function addSpace(space) {
  return {
    type: ADD_SPACE,
    payload: {
      space: constructSpace(space)
    }
  };
}


export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}


function storeSpaces(spaces) {
  // Generate team names
  const teams = generateTeams(spaces);

  return {
    type: STORE_SPACES,
    payload: {
      spaces: spaces.map((space) => constructSpace(space, teams))
    }
  };
}


/**
 * Fetches a list of spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @returns {Function} thunk
 */
export function fetchSpaces(sparkInstance) {
  return (dispatch) => {
    dispatch(updateSpacesStatus({isFetching: true}));
    return sparkInstance.conversation.list({
      ackFilter: `noack`,
      uuidEntryFormat: true,
      personRefresh: true,
      latestActivity: ``,
      lastViewableActivityOnly: true,
      participantAckFilter: `all`,
      // Only need 2 for One on One conversations
      participantsLimit: 2,
      conversationsLimit: 1000
    }).then((items) => dispatch(storeSpaces(items)));
  };
}


/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId) {
  return (dispatch) => sparkInstance.conversation.get({
    id: spaceId
  }, {
    latestActivity: true,
    activitiesLimit: 1,
    participantAckFilter: `all`,
    includeParticipants: true
  }).then((space) => dispatch(addSpace(space)));
}


/**
 * Creates team object to be stored
 *
 * @param {Object} space
 * @param {Object} teams
 * @returns {Object} formatted space object
 */
function constructSpace(space, teams) {
  const s = {
    latestActivity: space.activities.items[0],
    avatar: space.avatar,
    displayName: teams[space.id] ? `General` : space.displayName,
    id: space.id,
    url: space.url,
    lastReadableActivityDate: space.lastReadableActivityDate,
    lastSeenActivityDate: space.lastSeenActivityDate,
    conversationWebUrl: space.conversationWebUrl,
    participants: space.participants.items,
    type: space.tags.includes(TAG_ONE_ON_ONE) ? `direct` : `group`,
    published: space.published
  };

  if (space.team) {
    const {teamColor, generalConversationUuid, id, archived} = space.team;
    s.team = {
      displayName: teams[generalConversationUuid],
      color: teamColor,
      generalConversationUuid,
      id,
      archived
    };
  }

  return s;
}


/**
 * Generate object of ids and team names from collection of spaces
 *
 * @param {Object} spaces
 * @returns {Object} teams
 */
function generateTeams(spaces) {
  const teams = {};
  spaces.forEach((s) => {
    if (s.team && s.team.generalConversationUuid === s.id) {
      teams[s.id] = s.displayName;
    }
  });
  return teams;
}
