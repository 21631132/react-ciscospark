import {storeUsers} from '@ciscospark/redux-module-users';
import {storeActivities} from '@ciscospark/redux-module-activities';
import {uniqBy} from 'lodash';

import {
  TAG_LOCKED,
  constructSpace,
  constructSpaces
} from './helpers';

export const STORE_SPACES = 'spaces/STORE_SPACES';
export const UPDATE_SPACE_WITH_ACTIVITY = 'spaces/UPDATE_SPACE_WITH_ACTIVITY';
export const UPDATE_SPACE_READ = 'spaces/UPDATE_SPACE_READ';
export const REMOVE_SPACE = 'spaces/REMOVE_SPACE';
export const STORE_SPACE = 'spaces/STORE_SPACE';
export const STORE_INITIAL_SPACE = 'spaces/STORE_INITIAL_SPACE';


/**
 * Updates the last seen date of a space
 * @param {String} spaceId
 * @param {String} lastSeenDate
 * @returns {Object}
 */
export function updateSpaceRead(spaceId, lastSeenDate) {
  return {
    type: UPDATE_SPACE_READ,
    payload: {
      lastSeenDate,
      spaceId
    }
  };
}


export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}


export function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces: constructSpaces(spaces)
    }
  };
}

function storeInitialSpace(id) {
  return {
    type: STORE_INITIAL_SPACE,
    payload: {
      id
    }
  };
}


function decryptSpace(space) {
  if (typeof space.decrypt === 'function') {
    return space.decrypt()
      .then((s) => Promise.resolve(s));
  }

  return Promise.resolve(new Error('Space cannot be decrypted'));
}


/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @returns {Function} thunk
 */
export function getSpaces(sparkInstance, options = {}) {
  const listOptions = Object.assign({
    uuidEntryFormat: true,
    personRefresh: true,
    isActive: true,
    lastViewableActivityOnly: true,
    participantAckFilter: 'all',
    deferDecrypt: false,
    allFavorite: true,
    participantsLimit: -1
  }, options);
  const {deferDecrypt} = options;

  return (dispatch) => sparkInstance.internal.conversation
    .list(listOptions)
    .then((items) => {
      const users = [];
      const activities = [];

      const spaces = items.map((space) => {
        let decryptPromise;

        // Start decryption
        if (deferDecrypt && space.decrypt) {
          decryptPromise = decryptSpace(space)
            .then((decryptedSpace) => {
              if (decryptedSpace) {
                const s = Object.assign({}, decryptedSpace, {isDecrypting: false});
                const decryptedActivities = decryptedSpace.activities.items;
                const participants = decryptedSpace.participants.items;
                const activityActors = activities.map((a) => a.actor);

                dispatch(storeUsers([...participants, ...activityActors]));
                dispatch(storeActivities(decryptedActivities));
                dispatch(storeSpaces([s]));

                return Promise.resolve(constructSpace(s));
              }

              return Promise.resolve(new Error('Space was not decrypted correctly'));
            });
        }
        else {
          // Since we are not decrypting, save the redux store and do one big push
          users.push(...space.participants.items);
          activities.push(...space.activities.items);
        }

        return Object.assign({}, space, {isDecrypting: deferDecrypt, decryptPromise});
      });

      const uniqueUsers = uniqBy(users, 'id');
      const uniqueActivities = uniqBy(activities, 'id');

      dispatch(storeUsers(uniqueUsers));
      dispatch(storeActivities(uniqueActivities));
      dispatch(storeSpaces(spaces));

      return Promise.resolve(spaces);
    });
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @param {Boolean} isReadable if the activity is a readable activity
 * @returns {Object} action
 */
export function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity.id,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}


/**
 * Fetches a list of recent spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options to pass to SDK
 * @returns {Function} thunk
 */
export function fetchSpaces(sparkInstance, options = {}) {
  return (dispatch) =>
    dispatch(getSpaces(sparkInstance, {
      conversationsLimit: options.limit || 15,
      deferDecrypt: options.deferDecrypt || false
    }));
}


/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId) {
  return (dispatch) => {
    dispatch(storeInitialSpace(spaceId));

    return sparkInstance.internal.conversation.get({
      id: spaceId
    }, {
      activitiesLimit: 25,
      participantsLimit: -1,
      participantAckFilter: 'all',
      includeParticipants: true
    }).then((space) => {
      dispatch(storeUsers(space.participants.items));
      dispatch(storeActivities(space.activities.items));
      dispatch(storeSpaces([space]));

      return Promise.resolve(space);
    });
  };
}
