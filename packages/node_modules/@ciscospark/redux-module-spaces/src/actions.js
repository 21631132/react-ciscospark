export const STORE_SPACES = `spaces/STORE_SPACES`;
export const UPDATE_SPACES_STATUS = `spaces/UPDATE_SPACES_STATUS`;
export const UPDATE_SPACE_WITH_ACTIVITY = `spaces/UPDATE_SPACE_WITH_ACTIVITY`;
export const UPDATE_SPACE_READ = `spaces/UPDATE_SPACE_READ`;
export const REMOVE_SPACE = `spaces/REMOVE_SPACE`;
export const STORE_SPACE = `spaces/STORE_SPACE`;

const TAG_ONE_ON_ONE = `ONE_ON_ONE`;
const TAG_LOCKED = `LOCKED`;
const TAG_HIDDEN = `HIDDEN`;


/**
 * Fetches a list of spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options to pass to SDK
 * @returns {Function} thunk
 */

export function fetchSpaces(sparkInstance, options = {}) {
  return (dispatch) => {
    dispatch(updateSpacesStatus({isFetching: true}));
    return dispatch(getSpaces(sparkInstance, {
      conversationsLimit: 15,
      deferDecrypt: true,
      ...options
    }))
    .then(() => dispatch(getSpaces(sparkInstance, {
      conversationsLimit: 1000,
      ...options
    })))
    .then((spaces) => {
      dispatch(updateSpacesStatus({isFetching: false}));
      return Promise.resolve(spaces);
    });
  };
}

/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @returns {Function} thunk
 */

export function getSpaces(sparkInstance, options = {}) {
  const defaultOptions = {
    ackFilter: `noack`,
    uuidEntryFormat: true,
    personRefresh: true,
    latestActivity: ``,
    isActive: true,
    lastViewableActivityOnly: true,
    participantAckFilter: `all`,
    // Only need 2 for One on One conversations
    participantsLimit: 2
  };

  const listOptions = Object.assign({}, defaultOptions, options);

  return (dispatch) => sparkInstance.internal.conversation
    .list(listOptions)
    .then((items) => {
      const spaces = {};
      const decryptPromises = [];

      dispatch(updateSpacesStatus({isDecrypting: true}));

      items.forEach((space) => {
        if (!space.tags.includes(TAG_HIDDEN)) {
          spaces[space.id] = constructSpace(space, listOptions.deferDecrypt);
          if (space.decrypt) {
            decryptPromises.push(decryptSpace(space)
              .then((decryptedSpace) => { // eslint-disable-line max-nested-callbacks
                if (decryptedSpace) {
                  const s = constructSpace(decryptedSpace, false);
                  dispatch(storeSpace(s));
                  return Promise.resolve(s);
                }
                return Promise.resolve();
              })
            );
          }
        }
      });

      Promise.all(decryptPromises)
        .then((s) => {
          dispatch(updateSpacesStatus({isDecrypting: false}));
          return Promise.resolve(s);
        });

      return dispatch(storeSpaces(spaces));
    });
}


function decryptSpace(space) {
  if (typeof space.decrypt === `function`) {
    return space.decrypt()
      .then((s) => Promise.resolve(s));
  }
  return Promise.resolve();
}


/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId) {
  return (dispatch) => sparkInstance.internal.conversation.get({
    id: spaceId
  }, {
    activitiesLimit: 25,
    participantAckFilter: `all`,
    includeParticipants: true
  }).then((space) => {
    const constructedSpace = constructSpace(space);
    dispatch(storeSpace(constructedSpace));
    return constructedSpace;
  });
}


export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @param {Boolean} isReadable if the activity is a readable activity
 * @returns {Object} action
 */
export function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}

/**
 * Updates the last seen date of a space
 * @param {String} spaceId
 * @param {String} lastSeenDate
 * @returns {Object}
 */
export function updateSpaceRead(spaceId, lastSeenDate) {
  return {
    type: UPDATE_SPACE_READ,
    payload: {
      lastSeenDate,
      spaceId
    }
  };
}


function updateSpacesStatus(status) {
  return {
    type: UPDATE_SPACES_STATUS,
    payload: {
      status
    }
  };
}


function storeSpace(space) {
  return {
    type: STORE_SPACE,
    payload: {
      space
    }
  };
}


function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces
    }
  };
}


/**
 * Creates team object to be stored
 *
 * @param {Object} space
 * @param {Bool} isDecrypting
 * @returns {Object} formatted space object
 */
function constructSpace(space, isDecrypting) {
  const s = {
    latestActivity: constructLastestActivity(space.activities.items),
    avatar: space.avatar,
    displayName: space.displayName,
    id: space.id,
    url: space.url,
    lastReadableActivityDate: space.lastReadableActivityDate,
    lastSeenActivityDate: space.lastSeenActivityDate,
    conversationWebUrl: space.conversationWebUrl,
    participants: space.participants.items,
    type: space.tags.includes(TAG_ONE_ON_ONE) ? `direct` : `group`,
    published: space.published,
    tags: space.tags,
    team: space.team
  };

  if (isDecrypting === true || isDecrypting === false) {
    s.isDecrypting = isDecrypting;
  }

  return s;
}

function constructLastestActivity(items) {
  let latest = items.find((item) => [`tombstone`, `delete`].indexOf(item.verb) === -1);
  if (!latest) {
    latest = {
      actor: {
        displayName: ``
      },
      verb: ``,
      object: {
        displayName: ``
      }
    };
  }
  return latest;
}
