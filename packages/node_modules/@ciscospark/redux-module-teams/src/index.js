import {fromJS} from 'immutable';

export const STORE_TEAMS = `teams/STORE_TEAMS`;
export const UPDATE_STATUS = `teams/UPDATE_STATUS`;

export const initialState = fromJS({
  items: {},
  status: {
    isFetching: false,
    hasFetched: false
  }
});


export default function reducer(state = initialState, action) {
  switch (action.type) {
  case STORE_TEAMS:
    return state.setIn([`status`, `hasFetched`], true)
      .mergeDeepIn([`items`], action.payload.teams);
  case UPDATE_STATUS:
    return state.mergeDeepIn([`status`], action.payload.status);
  default:
    return state;
  }
}


export function fetchTeams(sparkInstance) {
  return (dispatch, getState) => {
    const currentTeams = getState().teams;
    if (!currentTeams.getIn([`status`, `isFetching`])) {
      dispatch(updateStatus({isFetching: true}));
      return sparkInstance.internal.team.list()
        .then((teams) => {
          dispatch(updateStatus({isFetching: false}));
          if (teams && teams.length) {
            return dispatch(storeTeams(constructTeams(teams)));
          }
          return Promise.resolve();
        })
        .catch(() => {
          dispatch(updateStatus({isFetching: false}));
          return Promise.reject();
        });
    }
    return Promise.resolve();
  };
}


function storeTeams(teams) {
  return {
    type: STORE_TEAMS,
    payload: {
      teams
    }
  };
}

function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

function constructTeams(teams) {
  const results = {};
  teams.forEach((team) => {
    results[team.id] = team;
  });
  return results;
}
