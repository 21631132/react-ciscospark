import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import {fetchCurrentUser, fetchToUser} from '@ciscospark/redux-module-user';
import {injectSpark} from '@ciscospark/react-redux-spark';
import TitleBar from '@ciscospark/react-component-title-bar';
import Notifications from '@ciscospark/react-container-notifications';
import ActivityMenu from './components/activity-menu';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import {ConnectedMessageComponent} from '@ciscospark/widget-message';
import {ConnectedMeetComponent} from '@ciscospark/widget-meet';
import Button from '@ciscospark/react-component-button';
import {ICON_TYPE_WAFFLE} from '@ciscospark/react-component-icon';


import {
  setActivityMenuVisible,
  toggleActivityMenu,
  setActivityMeet,
  setActivityMessage,
  ACTIVITY_TYPE_MEET,
  ACTIVITY_TYPE_MESSAGE
} from './actions';
import styles from './styles.css';

export const INITIAL_ACTIVITY_TYPE_MEET = `meet`;
export const INITIAL_ACTIVITY_TYPE_MESSAGE = `message`;
export const INITIAL_ACTIVITY_TYPE_MENU = `activity-menu`;

/**
 * MessageMeetWidget Component
 */
export class MessageMeetWidget extends Component {


  componentWillMount() {
    if (this.props.initialActivity === INITIAL_ACTIVITY_TYPE_MEET || this.props.startCall) {
      this.props.setActivityMeet();
    }
    if (this.props.initialActivity === INITIAL_ACTIVITY_TYPE_MENU) {
      this.props.setActivityMenuVisible(true);
    }
  }


  componentWillReceiveProps(nextProps) {
    const {
      user,
      spark,
      sparkState,
      toPersonEmail,
      toPersonId
    } = nextProps;

    const {
      authenticated,
      connected,
      registered
    } = sparkState;

    if (spark && connected && authenticated && registered) {
      if (!user.get(`currentUser`) && !user.getIn([`status`, `isFetchingCurrentUser`])) {
        nextProps.fetchCurrentUser(spark);
      }
      if (!user.get(`toUser`) && !user.getIn([`status`, `isFetchingToUser`])) {
        nextProps.fetchToUser({toPersonEmail, toPersonId}, spark);
      }
    }
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;

    return nextProps.sparkState.connected !== props.sparkState.connected
      || nextProps.user !== props.user
      || nextProps.conversation !== props.conversation
      || nextProps.avatar !== props.avatar
      || nextProps.indicators !== props.indicators
      || nextProps.widgetMessageMeet !== props.widgetMessageMeet;
  }

  @autobind
  handleActivityMeet() {
    const props = this.props;
    props.setActivityMeet();
    props.setActivityMenuVisible(false);
  }

  @autobind
  handleActivityMessage() {
    const props = this.props;
    props.setActivityMessage();
    props.setActivityMenuVisible(false);
  }

  @autobind
  handleMenuClick() {
    const props = this.props;
    props.toggleActivityMenu();
  }

  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  /**
   * Render
   *
   * @returns {Object}
   */
  render() {
    const props = this.props;
    const {
      avatar,
      spark,
      user,
      widgetMessageMeet
    } = props;

    const toUser = user.get(`toUser`);
    const activityMenuVisible = widgetMessageMeet.get(`activityMenuVisible`);
    const showMessage = widgetMessageMeet.get(`activityType`) === ACTIVITY_TYPE_MESSAGE;
    const showMeet = widgetMessageMeet.get(`activityType`) === ACTIVITY_TYPE_MEET;
    // Don't remove message component from DOM, just hide its display
    const messageComponentClassNames = classNames(`message-component-wrapper`, styles.messageComponentWrapper, showMessage ? `` : styles.hiddenComponent);

    // Don't load widgets until we have spark loaded and info on the toUser
    if (spark && toUser && toUser.id) {
      const toUserAvatarUrl = avatar.getIn([`items`, toUser.id]);
      return (
        <div className={classNames(`widget-message-meet`, styles.widgetMessageMeet)}>
          <div className={classNames(`banner`, styles.banner)} />
          <div className={classNames(`widget-message-meet-inner`, styles.widgetMessageMeetInner)}>
            {
              activityMenuVisible &&
              <div className={classNames(`activity-menu-wrapper`, styles.activityMenuWrapper)}>
                <ActivityMenu
                  onExit={this.handleMenuClick}
                  onMeet={this.handleActivityMeet}
                  onMessage={this.handleActivityMessage}
                />
              </div>
            }
            <div className={classNames(`activity-menu-button-wrapper`, styles.activityMenuButtonWrapper)}>
              <div className={classNames(`activity-menu-button`, styles.activityMenuButton)}>
                <Button iconType={ICON_TYPE_WAFFLE} onClick={this.handleMenuClick} />
              </div>
            </div>
            <div className={classNames(`title-bar-wrapper`, styles.titleBarWrapper)}>
              <TitleBar
                hasMenu
                image={toUserAvatarUrl}
                name={toUser.displayName}
                onMenuClick={this.handleMenuClick}
              />
            </div>
            {
              showMeet &&
              <ConnectedMeetComponent
                onEvent={this.handleEvent}
                shouldStartMeeting={props.startCall}
                spark={spark}
                toPersonAvatar={avatar[toUser.id]}
                toPersonId={toUser.id}
                toPersonName={toUser.displayName}
                user={user}
              />
            }
            <div className={messageComponentClassNames}>
              <ConnectedMessageComponent
                onEvent={this.handleEvent}
                spark={spark}
                toPersonId={toUser.id}
                user={user}
              />
            </div>
            <Notifications />
          </div>
        </div>
      );
    }
    // Show loading screen until spark is ready
    return <LoadingScreen />;
  }
}

const injectedPropTypes = {
  fetchCurrentUser: PropTypes.func.isRequired,
  fetchToUser: PropTypes.func.isRequired,
  setActivityMenuVisible: PropTypes.func.isRequired,
  toggleActivityMenu: PropTypes.func.isRequired,
  spark: PropTypes.object,
  sparkState: PropTypes.object.isRequired,
  user: PropTypes.object.isRequired
};

MessageMeetWidget.propTypes = {
  initialActivity: PropTypes.string,
  onEvent: PropTypes.func,
  startCall: PropTypes.bool,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string,
  ...injectedPropTypes
};

function mapStateToProps(state) {
  return {
    avatar: state.avatar,
    spark: state.spark.get(`spark`),
    sparkState: state.spark.get(`status`).toJS(),
    user: state.user,
    indicators: state.indicators,
    widgetMessageMeet: state.widgetMessageMeet
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    fetchCurrentUser,
    fetchToUser,
    setActivityMeet,
    setActivityMessage,
    setActivityMenuVisible,
    toggleActivityMenu
  }, dispatch)
)(injectSpark(MessageMeetWidget));
