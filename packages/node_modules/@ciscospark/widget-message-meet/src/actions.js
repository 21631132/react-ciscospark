import {
  deleteActivity,
  updateMercuryState,
  receiveMercuryActivity,
  receiveMercuryComment,
  VISIBLE_ACTIVITY_VERBS,
  VISIBLE_ACTIVITY_TYPES
} from '@ciscospark/redux-module-conversation';

import {
  removeInflightActivity
} from '@ciscospark/redux-module-activity';

import {
  setTyping
} from '@ciscospark/redux-module-indicators';


export const UPDATE_WIDGET_STATE = `UPDATE_WIDGET_STATE`;
export function updateWidgetState(state) {
  return {
    type: UPDATE_WIDGET_STATE,
    payload: {
      state
    }
  };
}

export const SET_SCROLL_POSITION = `SET_SCROLL_POSITION`;
export function setScrollPosition(scrollPosition) {
  return {
    type: SET_SCROLL_POSITION,
    payload: {
      scrollPosition
    }
  };
}

export function showScrollToBottomButton(isVisible) {
  return (dispatch) => {
    dispatch(updateWidgetState({
      showScrollToBottomButton: isVisible
    }));
  };
}


export function updateHasNewMessage(hasNew) {
  return (dispatch) => {
    dispatch(updateWidgetState({
      hasNewMessage: hasNew
    }));
  };
}

export function confirmDeleteActivity(activityId) {
  return (dispatch) => {
    dispatch(updateWidgetState({
      deletingActivityId: activityId,
      showAlertModal: true
    }));
  };
}

export function deleteActivityAndDismiss(conversation, activity, spark) {
  return (dispatch) => {
    dispatch(deleteActivity(conversation, activity, spark))
      .then(() => {
        dispatch(hideDeleteModal());
      });
  };
}

export function hideDeleteModal() {
  return (dispatch) => {
    dispatch(updateWidgetState({
      deletingActivityId: null,
      showAlertModal: false
    }));
  };
}

export function blurTextArea() {
  return (dispatch) => {
    dispatch(updateWidgetState({
      hasTextAreaFocus: false
    }));
  };
}

export function focusTextArea() {
  return (dispatch) => {
    dispatch(updateWidgetState({
      hasTextAreaFocus: true
    }));
  };
}


export function listenToMercuryActivity(conversationId, spark) {
  return (dispatch) => {
    dispatch(updateMercuryState({isListening: true}));
    spark.mercury.on(`event:status.start_typing`, (event) => {
      if (event.data.conversationId === conversationId) {
        dispatch(setTyping(event.data.actor.id, true));
      }
    });

    spark.mercury.on(`event:status.stop_typing`, (event) => {
      if (event.data.conversationId === conversationId) {
        dispatch(setTyping(event.data.actor.id, false));
      }
    });

    spark.mercury.on(`event:conversation.activity`, (event) => {
      const activity = event.data.activity;
      const isVisibleContent = VISIBLE_ACTIVITY_VERBS.indexOf(activity.verb) !== -1 && VISIBLE_ACTIVITY_TYPES.indexOf(activity.object.objectType) !== -1;
      // Ignore activity from other conversations
      if (activity.target.id === conversationId) {
        if (isVisibleContent) {
          dispatch(updateHasNewMessage(true));
          dispatch(receiveMercuryComment(activity));
          dispatch(removeInflightActivity(activity.clientTempId));
        }
        else if (activity.object.objectType === `activity`) {
          dispatch(receiveMercuryActivity(activity));
        }
      }
    });
  };
}
