import {createSelector} from 'reselect';

const getWidget = (state) => state.widgetMeet;
const getMedia = (state) => state.media;
const getSparkInstance = (state, props) => props.sparkInstance || state.spark.get('spark');
const getSparkState = (state) => state.spark.get('status');
const getConversation = (state) => state.conversation;
const getAvatars = (state) => state.avatar;
const getUsers = (state) => state.user;
const getMercury = (state) => state.mercury;


function buildCallFrom(isCall, callInstance, conversation) {
  let callFromPersonEmail, callFromPersonName, callFromUuid;
  if (isCall) {
    callFromUuid = callInstance.from ? callInstance.from.personUuid : callInstance.locus.host.id;
    const callFromPerson = conversation.get('participants').find((person) => person.get('id') === callFromUuid);
    // We *should* not get called from someone outside the conversation
    if (callFromPerson) {
      callFromPersonEmail = callFromPerson.get('emailAddress');
      callFromPersonName = callFromPerson.get('displayName');
    }
  }
  else {
    // Conversation data for meetings
    const conversationId = conversation.get('id');
    const displayName = conversation.get('displayName');
    callFromUuid = conversationId;
    callFromPersonName = displayName;
  }
  return {
    id: callFromUuid,
    name: callFromPersonName,
    email: callFromPersonEmail
  };
}


const getCall = createSelector(
  [getConversation, getMedia],
  (conversation, media) => media.getIn(['calls', conversation.get('locusUrl')])
);

const getMeetWidgetProps = createSelector(
  [
    getSparkState,
    getSparkInstance,
    getAvatars,
    getConversation,
    getMercury,
    getMedia,
    getUsers,
    getWidget,
    getCall
  ],
  (sparkState, sparkInstance, avatars, conversation, mercury, media, users, widgetMeet, call) => {
    let avatarImage, displayName;
    const conversationId = conversation.get('id');
    if (conversationId) {
      avatarImage = avatars.getIn(['items', conversationId]);
      displayName = conversation.get('displayName');
      const currentUserEmail = users.get('currentUser').email;

      // Need better way to store this in a single place
      if (conversation.get('tags').includes('ONE_ON_ONE')) {
        const toUser = conversation.get('participants')
          .filter((p) => p.get('emailAddress') !== currentUserEmail).first();
        displayName = toUser.get('displayName');
        avatarImage = avatars.getIn(['items', toUser.get('id')]);
      }
    }

    const hasCheckedWebRTCSupport = media.getIn(['webRTC', 'hasCheckedSupport']);
    const isWebRTCSupported = media.getIn(['webRTC', 'isSupported']);

    let callFrom, callInstance, callIsActive, callIsIncoming, callIsRinging, callState;
    if (call) {
      callState = call.get('callState').toJS();
      callInstance = call.get('instance');
      // Is the call active?
      const {
        direction,
        connected,
        ringing,
        joinedOnThisDevice,
        isCall,
        isInitiated
      } = callState;

      callIsRinging = ringing;
      callIsActive = connected && joinedOnThisDevice || direction === 'out';
      callIsIncoming = direction === 'in' && !joinedOnThisDevice;
      if (isInitiated && typeof isCall === 'boolean') {
        callFrom = buildCallFrom(isCall, callInstance, conversation);
      }
    }

    return {
      locusUrl: conversation.get('locusUrl'),
      sparkState: sparkState.toJS(),
      avatarImage,
      call,
      callFrom,
      callInstance,
      callIsActive,
      callIsIncoming,
      callIsRinging,
      callState,
      conversation,
      conversationId,
      displayName,
      hasCheckedWebRTCSupport,
      isWebRTCSupported,
      media,
      mercury,
      sparkInstance,
      users,
      widgetMeet
    };
  }
);

export default getMeetWidgetProps;
