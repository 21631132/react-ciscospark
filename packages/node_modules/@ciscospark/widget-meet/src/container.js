import React, {PropTypes, Component} from 'react';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';
import {intlShape, injectIntl} from 'react-intl';
import messages from './messages';

import {
  acceptIncomingCall,
  callUser,
  declineIncomingCall,
  listenForIncomingCalls,
  hangupCall
} from '@ciscospark/redux-module-media';

import {
  NOTIFICATION_TYPE_OTHER,
  createNotification
} from '@ciscospark/react-container-notifications';

import InactiveCall from './components/call-inactive';
import ActiveCall from './components/call-active';
import IncomingCall from './components/call-incoming';

import styles from './styles.css';

export class MeetWidget extends Component {

  componentDidMount() {
    const props = this.props;
    const {
      shouldStartMeeting
    } = this.props;
    const {
      conversation,
      media,
      onEvent,
      spark
    } = props;
    if (shouldStartMeeting
      && !media.getIn([`status`, `isDialing`])
      && !media.getIn([`status`, `isConnected`])) {
      this.handleCall();
    }
    if (!media.getIn([`status`, `isListening`]) && conversation.locusUrl) {
      props.listenForIncomingCalls(spark, conversation.locusUrl, onEvent);
    }
    if (media.getIn([`incomingCall`, `call`])) {
      this.incomingCallNotification(media.getIn([`incomingCall`, `call`]));
    }
  }

  componentWillReceiveProps(nextProps) {
    const {media, conversation, spark, onEvent} = nextProps;
    if (!media.getIn([`status`, `isListening`]) && conversation.locusUrl) {
      nextProps.listenForIncomingCalls(spark, conversation.locusUrl, onEvent);
    }
    if (media.getIn([`incomingCall`, `call`]) && !this.props.media.getIn([`incomingCall`, `call`])) {
      this.incomingCallNotification(media.getIn([`incomingCall`, `call`]));
    }
  }


  shouldComponentUpdate(nextProps) {
    const props = this.props;
    return nextProps.media !== props.media || nextProps.toPersonAvatar !== props.toPersonAvatar;
  }

  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undfined}
   */
  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  @autobind
  handleCall() {
    const props = this.props;
    const {
      toPersonId,
      spark
    } = this.props;
    props.callUser({userId: toPersonId}, spark);
  }

  @autobind
  handleHangup() {
    const props = this.props;
    const {
      media
    } = props;
    props.hangupCall(media.get(`call`));
  }

  @autobind
  handleAnswer() {
    const {media, spark} = this.props;
    const incomingCall = media.getIn([`incomingCall`, `call`]);
    this.props.acceptIncomingCall(incomingCall, spark);
  }

  @autobind
  handleDecline() {
    const {media} = this.props;
    const incomingCall = media.getIn([`incomingCall`, `call`]);
    this.props.declineIncomingCall(incomingCall);
  }

  incomingCallNotification(incomingCall) {
    const {intl} = this.props;
    const {formatMessage} = intl;
    const details = {
      username: incomingCall.from.person.name,
      message: formatMessage(messages.incomingCallMessage),
      avatar: this.props.avatar.get(`items`).toJS()[incomingCall.from.person.id]
    };
    this.props.createNotification(incomingCall.locusUrl, NOTIFICATION_TYPE_OTHER, details);
  }

  render() {
    const {
      handleAnswer,
      handleCall,
      handleDecline,
      handleHangup,
      props
    } = this;
    const {
      intl,
      toPersonAvatar,
      toPersonName
    } = this.props;
    const {
      media
    } = props;
    const remoteUrl = media.getIn([`remoteStream`, `url`]);
    const localUrl = media.getIn([`localStream`, `url`]);
    const isConnected = media.getIn([`status`, `isConnected`]);
    const isActiveCall = media.getIn([`status`, `isDialing`]) || isConnected;
    const isIncomingCall = media.getIn([`status`, `isRinging`]);

    return (
      <div className={classNames(styles.meetWidgetContainer, `meet-widget-container`)}>
        {
          !isActiveCall && !isIncomingCall &&
          <InactiveCall
            avatarImage={toPersonAvatar}
            intl={intl}
            onCallClick={handleCall}
            toPersonName={toPersonName}
          />
        }
        {
          isActiveCall &&
          <ActiveCall
            intl={intl}
            isConnected={isConnected}
            localMediaStreamUrl={localUrl}
            onHangupClick={handleHangup}
            remoteMediaStreamUrl={remoteUrl}
          />
        }
        {
          isIncomingCall &&
          <IncomingCall
            avatarImage={toPersonAvatar}
            intl={intl}
            onAnswerClick={handleAnswer}
            onDeclineClick={handleDecline}
            toPersonName={toPersonName}
          />
        }
      </div>
    );
  }
}

const injectedPropTypes = {
  intl: intlShape.isRequired,
  avatar: PropTypes.object.isRequired,
  spark: PropTypes.object.isRequired,
  media: PropTypes.object.isRequired,
  conversation: PropTypes.object.isRequired,
  acceptIncomingCall: PropTypes.func.isRequired,
  callUser: PropTypes.func.isRequired,
  createNotification: PropTypes.func.isRequired,
  declineIncomingCall: PropTypes.func.isRequired,
  hangupCall: PropTypes.func.isRequired,
  listenForIncomingCalls: PropTypes.func.isRequired
};

MeetWidget.propTypes = {
  onEvent: PropTypes.func,
  shouldStartMeeting: PropTypes.bool,
  spark: PropTypes.object.isRequired,
  toPersonAvatar: PropTypes.string,
  toPersonId: PropTypes.string.isRequired,
  toPersonName: PropTypes.string.isRequired,
  ...injectedPropTypes
};

function mapStateToProps(state, ownProps) {
  return {
    spark: ownProps.spark || state.spark,
    avatar: state.avatar,
    media: state.media,
    conversation: state.conversation
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    acceptIncomingCall,
    callUser,
    createNotification,
    declineIncomingCall,
    hangupCall,
    listenForIncomingCalls
  }, dispatch)
)(injectIntl(MeetWidget));
