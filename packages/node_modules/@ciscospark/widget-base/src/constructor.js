import React, {Component} from 'react';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import {connect, Provider} from 'react-redux';
import {bindActionCreators} from 'redux';
import {autobind} from 'core-decorators';
import {fromJS} from 'immutable';
import {addLocaleData, IntlProvider, intlShape, injectIntl} from 'react-intl';
import {injectSpark} from '@ciscospark/react-redux-spark';
import metricsReducer, {injectSparkMetrics} from '@ciscospark/react-redux-spark-metrics';
import {getDisplayName} from '@ciscospark/react-component-utils';

import createRootReducer from './root-reducer';
import initStore from './store';
import {removeWidget} from './actions';
import registerWidget from './browser-globals';
import setupDataAPI from './data-api';


const propTypes = {
  accessToken: PropTypes.string.isRequired,
  injectProvider: PropTypes.bool,
  logLevel: PropTypes.oneOf([
    'silent',
    'error',
    'warn',
    'log',
    'info',
    'debug',
    'trace'
  ]),
  metrics: PropTypes.object,
  onEvent: PropTypes.func,
  spark: PropTypes.object,
  store: PropTypes.object,
  removeWidget: PropTypes.func
};


const defaultProps = {
  injectProvider: true,
  logLevel: 'error',
  metrics: {},
  onEvent: () => {},
  store: undefined,
  spark: undefined,
  removeWidget: () => {}
};


const defaultOptions = fromJS({
  intl: {
    messages: null,
    locale: 'en'
  },
  browserGlobals: true,
  dataAPI: true,
  metrics: false,
  reducers: {},
  propTypes
});

/**
 * Constructs a connected component with necessary redux modules
 * @param {String} widgetName Unique name for widget, camel cased
 * @param  {Object} Widget React container for the widget
 * @param  {Object} [options={}] Options matching format of defaultOptions above
 * @returns {Object} React Component
 */
export default function constructSparkWidget(widgetName, Widget, options = {}) {
  let widgetEl;
  let WidgetComponent = Widget;
  let widgetOptions = defaultOptions.mergeDeep(options);

  if (widgetOptions.get('metrics')) {
    widgetOptions = widgetOptions.setIn(['reducers', 'metricsStore'], metricsReducer);
  }

  const reducers = widgetOptions.get('reducers');
  const allowedPropTypes = widgetOptions.get('propTypes').toJS();
  // Setup Reducers
  const rootReducer = createRootReducer(reducers.toJS());

  /**
   * Injects widget into DOM
   * @param  {DOMNode} element DOM Element or Node where widget will inject
   * @param  {Object} props Any props that should be passed to widget
   * @returns {DOMNode} DOM Element where widget is rendered
   */
  function initSparkWidget(element, props) {
    // Filter props based on options passed to constructor
    const filteredProps = {};
    const allowedProps = Object.keys(allowedPropTypes);

    Object.keys(props).forEach((k) => {
      if (allowedProps.includes(k)) {
        filteredProps[k] = props[k];
      }
    });

    ReactDOM.render(<SparkWidget {...filteredProps} />, element);

    widgetEl = element;
    return element;
  }

  function removeSparkWidget(el) {
    return ReactDOM.unmountComponentAtNode(el);
  }

  const registerTuple = [widgetName, initSparkWidget, removeSparkWidget];

  // Setup Browser globals for widget
  if (widgetOptions.get('browserGlobals')) {
    registerWidget(...registerTuple);
  }

  // Setup Data API
  if (widgetOptions.get('dataAPI')) {
    setupDataAPI(...registerTuple);
  }


  // Setup React-intl
  const intlMessages = widgetOptions.getIn(['intl', 'messages']).toJS();
  const intlLocale = widgetOptions.getIn(['intl', 'locale']);
  if (intlMessages) {
    // eslint-disable-reason Dynamically loading locale data to lower overhead
    // eslint-disable-next-line import/no-dynamic-require, global-require
    const localeData = require(`react-intl/locale-data/${intlLocale}`);
    addLocaleData(localeData);
    allowedPropTypes.intl = intlShape;
  }

  WidgetComponent = injectSpark(WidgetComponent);

  if (intlMessages) {
    WidgetComponent = injectIntl(WidgetComponent);
  }

  if (widgetOptions.get('metrics')) {
    WidgetComponent = injectSparkMetrics(WidgetComponent, widgetName);
  }

  // Connect widget to Redux store
  // Will prefer to return passed props than what's stored in state
  WidgetComponent = connect(
    (state, ownProps) => Object.assign({}, state, ownProps),
    (dispatch) => bindActionCreators({removeWidget}, dispatch)
  )(WidgetComponent);


  /**
   * Spark Widget HOC
   * @type {class}
   * @extends {Component}
   */
  class SparkWidget extends Component {
    constructor(props) {
      super(props);
      this.el = widgetEl;
      this.handleEvent = this.handleEvent.bind(this);
    }

    shouldComponentUpdate() {
      return true;
    }

    @autobind
    handleEvent(name, data) {
      const {
        onEvent
      } = this.props;
      if (typeof onEvent === 'function') {
        this.props.onEvent(name, data);
      }
    }

    render() {
      const {
        store,
        injectProvider
      } = this.props;
      let widgetStore = store;
      if (injectProvider && !widgetStore) {
        widgetStore = initStore(rootReducer);
      }

      let widget = <WidgetComponent {...this.props} onEvent={this.handleEvent} />;

      if (widgetStore && injectProvider) {
        widget = <Provider store={widgetStore}>{widget}</Provider>;
      }

      if (intlMessages) {
        widget = (
          <IntlProvider locale={intlLocale} messages={intlMessages} >
            {widget}
          </IntlProvider>
        );
      }

      return widget;
    }
  }

  SparkWidget.propTypes = propTypes;
  SparkWidget.defaultProps = defaultProps;

  SparkWidget.displayName = `SparkWidget(${getDisplayName(Widget)})`;
  SparkWidget.Widget = Widget;

  return SparkWidget;
}
