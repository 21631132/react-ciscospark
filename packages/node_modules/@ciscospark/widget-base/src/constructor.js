import React, {Component, PropTypes} from 'react';
import ReactDOM from 'react-dom';
import {connect, Provider} from 'react-redux';
import {bindActionCreators} from 'redux';
import {fromJS} from 'immutable';
import {addLocaleData, IntlProvider, injectIntl} from 'react-intl';

import {injectSpark} from '@ciscospark/react-redux-spark';

import createRootReducer from './root-reducer';
import initStore from './store';
import {removeWidget} from './actions';
import registerWidget from './browser-globals';
import setupDataAPI from './data-api';


function getDisplayName(C) {
  return C.displayName || C.name || `C`;
}

const defaultOptions = fromJS({
  intl: {
    messages: null,
    locale: `en`
  },
  browserGlobals: true,
  dataAPI: true,
  reducers: {}
});

/**
 * Constructs a connected component with necessary redux modules
 * @param {String} widgetName Unique name for widget, camel cased
 * @param  {Object} Widget React container for the widget
 * @param  {Object} [options={}] Options matching format of defaultOptions above
 * @returns {Object} React Component
 */
export default function constructSparkWidget(widgetName, Widget, options = {}) {
  let widgetEl;
  const widgetOptions = defaultOptions.mergeDeep(options);
  const reducers = widgetOptions.get(`reducers`);

  /**
   * Injects widget into DOM
   * @param  {DOMNode} element DOM Element or Node where widget will inject
   * @param  {Object} props Any props that should be passed to widget
   * @returns {DOMNode} DOM Element where widget is rendered
   */
  function initSparkWidget(element, props) {
    ReactDOM.render(
      <SparkWidget {...props} />, element
    );
    // Store widget element
    // Create Unique ID
    // Attach ID to element
    // Store widgetInstance
    // Attach remove method
    // Attach DOM mutation observer for element remove
    // Fire remove method when this happens
    // Prevent our own dom removal if this happens
    widgetEl = element;
    return element;
  }

  function removeSparkWidget(el) {
    ReactDOM.unmountComponentAtNode(el);
  }

  const registerTuple = [widgetName, initSparkWidget, removeSparkWidget];

  // Setup Browser globals for widget
  if (widgetOptions.get(`browserGlobals`)) {
    registerWidget(...registerTuple);
  }

  // Setup Data API
  if (widgetOptions.get(`dataAPI`)) {
    setupDataAPI(...registerTuple);
  }

  // Setup Reducers
  const rootReducer = createRootReducer(reducers.toJS());
  const defaultStore = initStore(rootReducer);

  // Setup React-intl
  const intlMessages = widgetOptions.getIn([`intl`, `messages`]).toJS();
  const intlLocale = widgetOptions.getIn([`intl`, `locale`]);
  if (intlMessages) {
    // eslint-disable-next-line global-require
    const localeData = require(`react-intl/locale-data/${intlLocale}`);
    addLocaleData(localeData);
  }

  let WidgetComponent = injectSpark(Widget);

  if (intlMessages) {
    WidgetComponent = injectIntl(WidgetComponent);
  }

  // Connect widget to Redux store
  // Will prefer to return passed props than what's stored in state
  WidgetComponent = connect(
    (state, ownProps) => Object.assign({}, state, ownProps),
    (dispatch) => bindActionCreators({removeWidget}, dispatch)
  )(WidgetComponent);


  /**
   * Spark Widget HOC
   * @type {class}
   * @extends {Component}
   */
  class SparkWidget extends Component {

    constructor(props) {
      super(props);
      this.el = widgetEl;
    }

    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    }

    handleEvent(name, data) {
      const detail = {
        resource: name.split(`:`)[0],
        event: name.split(`:`)[1],
        actorId: data.actor.id,
        data
      };

      // Dispatch DOM event
      const event = new CustomEvent(name, {
        detail
      });
      this.el.dispatchEvent(event);

      // Trigger ampersand events
      this.trigger(name, detail);

      // Trigger onEvent callback
      if (this.options.onEvent) {
        return this.options.onEvent(name, detail);
      }

      return this;
    }

    render() {
      const store = this.props.store || defaultStore;
      let widget = <WidgetComponent {...this.props} />;

      if (store && this.props.injectProvider) {
        widget = <Provider store={store}>{widget}</Provider>;
      }

      if (intlMessages) {
        widget = ( // eslint-disable-line no-extra-parens
          <IntlProvider locale={intlLocale} messages={intlMessages} >
            {widget}
          </IntlProvider>
        );
      }

      return widget;
    }
  }

  const injectedProps = {
    removeWidget: PropTypes.func
  };

  SparkWidget.propTypes = {
    injectProvider: PropTypes.bool,
    store: PropTypes.object,
    ...injectedProps
  };

  SparkWidget.defaultProps = {
    injectProvider: true
  };

  SparkWidget.displayName = `SparkWidget(${getDisplayName(Widget)})`;
  SparkWidget.Widget = Widget;

  return SparkWidget;
}
