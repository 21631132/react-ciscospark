import React, {Component} from 'react';
import {
  applyMiddleware,
  combineReducers,
  createStore,
  compose
} from 'redux';
import {Provider} from 'react-redux';
import {createLogger} from 'redux-logger';
import thunk from 'redux-thunk';
import PropTypes from 'prop-types';
import sparkReducer from '@ciscospark/react-redux-spark';
import usersReducer from '@ciscospark/redux-module-users';
import metricsReducer from '@ciscospark/react-redux-spark-metrics';

import {REMOVE_WIDGET} from './withRemoveWidget';

function constructReducers(reducers) {
  const rootReducers = reducers;

  rootReducers.spark = sparkReducer;
  rootReducers.users = usersReducer;
  rootReducers.metricsStore = metricsReducer;
  const widgetReducer = combineReducers(rootReducers);

  return (state, action) => {
    if (action.type === REMOVE_WIDGET) {
      return undefined;
    }
    if (widgetReducer) {
      return widgetReducer(state, action);
    }
    return state;
  };
}

/**
 * HOC for injecting an initial Redux state from reducers and enhancers
 * @param {Object} options
 * @param {Object} options.reducers object of reducers
 * @param {Object} options.enhancers enhancers that will be composed and used for createStore
 * @returns {Function} creates a wrapped React component
 */
export default function withInitialState({reducers = {}, enhancers = {}}) {
  const devtools = window.devToolsExtension || (() => (noop) => noop);
  const middlewares = [thunk];

  if (process.env.NODE_ENV !== 'production') {
    const logger = createLogger({
      level: 'info',
      duration: true,
      collapsed: false,
      logErrors: true
    });
    middlewares.push(logger);
  }


  return (BaseComponent) => {
    class WithInitialState extends Component {
      constructor(props) {
        super(props);
        this.widgetReducer = constructReducers(reducers);
        this.store = createStore(this.widgetReducer, compose(
          applyMiddleware(thunk),
          devtools(),
          ...enhancers
        ));
      }

      render() {
        const {props} = this;
        // Do not inject provider if spark object already exists in props
        if (props.spark) {
          return <BaseComponent {...props} />;
        }
        return (
          <Provider store={this.store}>
            <BaseComponent {...props} />
          </Provider>
        );
      }
    }
    WithInitialState.propTypes = {
      spark: PropTypes.object
    };

    WithInitialState.defaultProps = {
      spark: undefined
    };

    return WithInitialState;
  };
}
