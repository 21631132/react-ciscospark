import {fromJS} from 'immutable';

export const initialState = fromJS({
  items: {},
  avatarsInFlight: {}
});

export const ADD_AVATAR = `avatar/ADD_AVATAR`;
export const ADD_AVATAR_BEGIN = `avatar/ADD_AVATAR_BEGIN`;

export default function reducer(state = initialState, action) {
  switch (action.type) {
  case ADD_AVATAR:
    {
      const {userId, avatar} = action.payload;
      return state.setIn([`items`, userId], avatar).deleteIn([`avatarsInFlight`, userId]);
    }
  case ADD_AVATAR_BEGIN:
    return state.setIn([`avatarsInFlight`, action.payload.userId], true);
  default:
    return state;
  }
}

/**
 * Fetches a group of users' avatars
 * @param {Array} userIds
 * @param {object} spark
 * @returns {Thunk}
 */
export function fetchAvatarsForUsers(userIds, spark) {
  const promises = [];
  return (dispatch) => {
    userIds.forEach((userId) => {
      promises.push(dispatch(fetchAvatarForUserId(userId, spark)));
    });
    return Promise.all(promises);
  };
}

/**
 * Fetches an avatar for a given user id
 * @param {string} userId
 * @param {object} spark
 * @returns {Thunk}
 */
export function fetchAvatarForUserId(userId, spark) {
  return (dispatch, getState) => {
    const state = getState().avatar;
    const fetched = state.hasIn([`items`, userId]);
    const fetching = state.hasIn([`avatarsInFlight`, userId]);
    if (fetched || fetching) {
      return Promise.resolve();
    }

    dispatch(addAvatarBegin(userId));
    return spark.people.get(userId)
      .then((person) => dispatch(addAvatar(userId, person.avatar)))
      .catch(() => dispatch(addAvatar(userId, undefined)));
  };
}

function addAvatar(userId, avatar) {
  return {
    type: ADD_AVATAR,
    payload: {
      userId,
      avatar
    }
  };
}

function addAvatarBegin(userId) {
  return {
    type: ADD_AVATAR_BEGIN,
    payload: {
      userId
    }
  };
}
