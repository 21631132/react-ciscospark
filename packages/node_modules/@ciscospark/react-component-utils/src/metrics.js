const METRIC_NS = `ciscospark_widget_`;
const LOAD_START = `widget:ready`;

const metrics = {};
/**
 * Temporarily save metric to sessionStorage
 * @param {string} key
 * @param  {any} data
 * @returns {null}
 */
export function saveTempMetric(key, data) {
  metrics[key] = data;
}

export function getTempMetric(key) {
  const data = metrics[key];
  return {key, data};
}

/**
 * Immediately send metric
 * @param  {object} metric
 * @param  {string} metric.key
 * @param  {any} metric.data
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendPerfMetric({key, data}, spark) {
  const [name, action] = key.split(`:`);
  const formattedData = {
    type: [`operational`],
    tags: {
      action
    },
    fields: {
      protocol: window.location.protocol,
      hostname: window.location.hostname,
      pathname: window.location.pathname,
      widgetVersion: process.env.REACT_CISCOSPARK_VERSION,
      jsSdkVersion: spark.version,
      data
    }
  };
  return spark.metrics.submitClientMetrics(`${METRIC_NS}${name}`, formattedData);
}

/**
 * Send metric stored in session
 * @param  {string} key
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendTempMetric(key, spark) {
  let metric = getTempMetric(key);
  metric = isNaN(metric) ? metric : Number(metric);
  return sendPerfMetric(metric, spark);
}

/**
 * Save start time
 * @param  {object} spark
 * @returns {null}
 */
export function saveAndSendLoadStart(spark) {
  const now = saveLoadStart();
  sendLoadStart(spark);
  return now;
}

/**
 * Send start time
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendLoadStart(spark) {
  const data = getTempMetric(LOAD_START);
  return sendPerfMetric(data, spark);
}

/**
 * Save start time
 * @param  {object} spark
 * @returns {number} now
 */
export function saveLoadStart() {
  const now = window.performance.now();
  saveTempMetric(LOAD_START, now);
  return now;
}

function getElapsedTime() {
  const now = window.performance.now();
  const start = getTempMetric(LOAD_START).data;
  return start && now - start;
}

/**
 * Save time elapsed for event
 * @type {[type]}
 */

export function saveElapsedTime(key) {
  const elapsedTime = getElapsedTime();
  saveTempMetric(key, elapsedTime);
}

/**
 * Send time from starting load
 * @param  {string} key
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendElapsedTimeMetric(key, spark) {
  let elapsedTime = getElapsedTime();
  if (!elapsedTime) {
    saveAndSendLoadStart(spark);
    elapsedTime = 0;
  }
  return sendPerfMetric({key, data: elapsedTime}, spark);
}

export function sendDurationMetric(key, start, end, spark) {
  const startMetric = getTempMetric(start).data;
  const endMetric = getTempMetric(end).data;
  return sendPerfMetric({key, data: endMetric - startMetric}, spark);
}
