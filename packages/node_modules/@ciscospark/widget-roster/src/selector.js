import {createSelector} from 'reselect';
import {concat, has} from 'lodash';

import messages from './messages';

const getSparkInstance = (state, props) => props.sparkInstance || state.spark.get(`spark`);
const getConversation = (state) => state.conversation;
const getCurrentUser = (state) => state.user.get(`currentUser`);
const getAvatars = (state) => state.avatar;
const getSearch = (state) => state.search;
const getWidget = (state) => state.widgetRoster;
const getFormatMessage = (state, props) => props.intl.formatMessage;

const getSearchResults = createSelector(
  [
    getSearch,
    getWidget,
    getAvatars,
    getCurrentUser
  ],
  (search, widgetRoster, avatars, currentUser) => {
    const searchTerm = widgetRoster.get(`searchTerm`);
    if (searchTerm && search.hasIn([`searchResults`, searchTerm])) {
      const searchResults = search.getIn([`searchResults`, searchTerm]).toJS();
      const results = [];
      if (searchResults.results) {
        searchResults.results.forEach((user) => {
          if (user.id !== currentUser.id) {
            user.avatar = avatars.getIn([`items`, user.id]);
            results.push(user);
          }
        });
        searchResults.results = results;
      }

      return searchResults;
    }
    return undefined;
  }
);

export const getParticipants = createSelector(
  [
    getConversation,
    getCurrentUser,
    getAvatars,
    getFormatMessage
  ],
  (
    conversation,
    currentUser,
    avatars,
    formatMessage
  ) => {
    const people = [];
    let hasExternalParticipants = false;
    let count = 0;

    const participants = conversation.get(`participants`).toJS();
    const inFlightParticipants = conversation.get(`inFlightParticipants`).toJS();
    const isConsumerOrg = currentUser.orgId === `consumer`;
    function mapParticipant(participant) {
      participant.avatar = avatars.getIn([`items`, participant.id]);
      participant.isExternal = currentUser
        && !isConsumerOrg
        && currentUser.orgId !== `consumer`
        && currentUser.orgId !== participant.orgId;

      if (participant.isExternal) {
        hasExternalParticipants = true;
      }
      participant.displayName = participant.displayName ? participant.displayName : participant.name;
      participant.inFlight = has(inFlightParticipants, [`removing`, participant.id])
        || has(inFlightParticipants, [`adding`, participant.id]);
      return participant;
    }

    const currentUserParticipant = [];
    const moderatorParticipants = [];
    let otherParticipants = [];
    participants
      .sort(sortParticipants)
      .forEach((p) => {
        const participant = mapParticipant(p);
        if (participant.roomProperties && participant.roomProperties.isModerator) {
          moderatorParticipants.push(participant);
        }
        else if (participant.id === currentUser.id) {
          currentUserParticipant.push(participant);
        }
        else {
          otherParticipants.push(participant);
        }
        count = count + 1;
      });

    // Add inflight adding participants to other participants
    otherParticipants = concat(currentUserParticipant, otherParticipants, Object.values(inFlightParticipants.adding).map(mapParticipant));

    if (moderatorParticipants.length > 0) {
      people.push({
        label: formatMessage(messages.moderators),
        people: moderatorParticipants
      });
    }

    if (otherParticipants.length > 0) {
      people.push({
        label: formatMessage(messages.participants),
        people: otherParticipants
      });
    }

    return {
      hasExternalParticipants,
      count,
      people
    };
  }
);

export const getRosterWidgetProps = createSelector(
  [
    getSparkInstance,
    getConversation,
    getCurrentUser,
    getAvatars,
    getSearchResults,
    getWidget,
    getParticipants
  ],
  // eslint-disable-next-line max-params
  (
    sparkInstance,
    conversation,
    currentUser,
    avatars,
    searchResults,
    widgetRoster,
    participants
  ) => {

    const isOneOnOne = conversation.getIn([`status`, `isOneOnOne`]);
    const isLocked = conversation.getIn([`status`, `isLocked`]);
    const isModerator = conversation.getIn([`status`, `isModerator`]);
    const canEditRoster = !isOneOnOne && (isLocked && isModerator || !isLocked);
    const isConsumerOrg = currentUser.orgId === `consumer`;

    return {
      sparkInstance,
      canEditRoster,
      searchResults,
      participants,
      isConsumerOrg,
      editingParticipant: widgetRoster.get(`editingParticipant`),
      currentView: widgetRoster.get(`currentView`),
      searchTerm: widgetRoster.get(`searchTerm`)
    };
  }
);


function sortParticipants(participantA, participantB) {
  const A = participantA.displayName;
  const B = participantB.displayName;
  // eslint-disable-next-line no-nested-ternary
  return A < B ? -1 : A > B ? 1 : 0;
}
