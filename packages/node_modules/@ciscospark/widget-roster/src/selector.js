import {createSelector} from 'reselect';
import {concat, has} from 'lodash';

const getSparkInstance = (state, props) => props.sparkInstance || state.spark.get(`spark`);
const getConversation = (state) => state.conversation;
const getUser = (state) => state.user;
const getAvatars = (state) => state.avatar;
const getSearch = (state) => state.search;
const getWidget = (state) => state.widgetRoster;

const getSearchResults = createSelector(
  [
    getSearch,
    getWidget,
    getAvatars
  ],
  (search, widgetRoster, avatars) => {
    const searchTerm = widgetRoster.get(`searchTerm`);
    if (searchTerm && search.hasIn([`searchResults`, searchTerm])) {
      const searchResults = search.getIn([`searchResults`, searchTerm]).toJS();
      if (searchResults.results) {
        searchResults.results = searchResults.results.map((user) => {
          user.avatar = avatars.getIn([`items`, user.id]);
          return user;
        });
      }
      return searchResults;
    }
    return undefined;
  }
);

export const getRosterWidgetProps = createSelector(
  [
    getSparkInstance,
    getConversation,
    getUser,
    getAvatars,
    getSearchResults,
    getWidget
  ],
  // eslint-disable-next-line max-params
  (sparkInstance, conversation, user, avatars, searchResults, widgetRoster) => {
    const participants = conversation.get(`participants`).toJS();
    const inFlightParticipants = conversation.get(`inFlightParticipants`).toJS();
    const currentUser = user.get(`currentUser`);
    const isConsumerOrg = currentUser.orgId === `consumer`;

    let hasExternalParticipants = false;

    const sortParticipants = (participantA, participantB) => {
      const A = participantA.displayName;
      const B = participantB.displayName;
      // eslint-disable-next-line no-nested-ternary
      return A < B ? -1 : A > B ? 1 : 0;
    };

    const mapParticipant = (participant) => {
      participant.avatar = avatars.getIn([`items`, participant.id]);
      participant.external = currentUser && !isConsumerOrg && currentUser.orgId !== participant.orgId;
      if (participant.external) {
        hasExternalParticipants = true;
      }
      participant.displayName = participant.displayName ? participant.displayName : participant.name;
      participant.inFlight = has(inFlightParticipants, [`removing`, participant.id]) || has(inFlightParticipants, [`adding`, participant.id]);
      return participant;
    };

    const currentUserParticipant = [];
    const moderatorParticipants = [];
    let otherParticipants = [];
    participants
      .sort(sortParticipants)
      .forEach((p) => {
        const participant = mapParticipant(p);
        if (participant.id === currentUser.id) {
          currentUserParticipant.push(participant);
        }
        else if (participant.roomProperties && participant.roomProperties.isModerator) {
          moderatorParticipants.push(participant);
        }
        else {
          otherParticipants.push(participant);
        }
      });

    // Add inflight adding participants to other participants
    otherParticipants = concat(otherParticipants, Object.values(inFlightParticipants.adding).map(mapParticipant));

    const isOneOnOne = conversation.getIn([`status`, `isOneOnOne`]);
    const isLocked = conversation.getIn([`status`, `isLocked`]);
    const isModerator = conversation.getIn([`status`, `isModerator`]);
    const canEditRoster = !isOneOnOne && (isLocked && isModerator || !isLocked);

    const propsObject = {
      canEditRoster,
      currentView: widgetRoster.get(`currentView`),
      editingParticipant: widgetRoster.get(`editingParticipant`),
      hasExternalParticipants,
      isConsumerOrg,
      searchTerm: widgetRoster.get(`searchTerm`),
      sparkInstance,
      participants,
      participantsCurrentUser: currentUserParticipant,
      participantsOther: otherParticipants,
      participantsModerators: moderatorParticipants,
      searchResults
    };
    return propsObject;
  }
);
