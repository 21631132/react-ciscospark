import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';

import {fetchAvatarsForUsers} from '@ciscospark/redux-module-avatar';

import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Button from '@ciscospark/react-component-button';

import {
  ICON_TYPE_ADD,
  ICON_TYPE_EXIT,
  ICON_TYPE_WAFFLE,
  default as Icon
} from '@ciscospark/react-component-icon';

import {getRosterWidgetProps} from './selector';
import {setWidgetViewAdd, setWidgetViewMain, VIEW_ADD} from './actions';
import messages from './messages';

import styles from './styles.css';

import ParticipantList from './components/participant-list';
import AddParticipant from './components/add-participant';
import ExternalParticipantMessage from './components/external-participant';

/**
 * RosterWidget Container
 * @extends Component
 */
export class RosterWidget extends Component {

  shouldComponentUpdate(nextProps) {
    return nextProps.avatar.get(`items`) !== this.props.avatar.get(`items`) ||
      nextProps.conversation.get(`participants`) !== this.props.conversation.get(`participants`) ||
      nextProps.canEditRoster !== this.props.canEditRoster ||
      nextProps.widgetRoster.getIn([`widgetState`, `currentView`]) !== this.props.widgetRoster.getIn([`widgetState`, `currentView`]);
  }

  componentWillUpdate(nextProps) {
    this.props.fetchAvatarsForUsers(nextProps.participants.map((user) => user.userId), this.props.sparkInstance);
  }

  @autobind
  handleMenuClick() {
    this.props.onClickMenu();
  }

  @autobind
  handleCloseClick() {
    this.props.onClickClose();
  }

  @autobind
  handleAddPeople() {
    this.props.setWidgetViewAdd();
  }

  @autobind
  handleAddPeopleDismiss() {
    this.props.setWidgetViewMain();
  }

  /**
   * Renders the main area of the widget
   *
   * @returns {object}
   */
  render() {
    let mainArea;
    let participantCountDisplay;
    const {formatMessage} = this.props.intl;
    // eslint-disable-next-line no-negated-condition
    if (!this.props.conversation.has(`participants`)) {
      mainArea = <LoadingScreen />;
    }
    else {
      const {
        canEditRoster,
        hasExternalParticipants,
        participantsCurrentUser,
        participantsModerators,
        participantsOther,
        widgetRoster
      } = this.props;
      participantCountDisplay = `(${this.props.participants.length})`;
      let content;
      if (widgetRoster.getIn([`widgetState`, `currentView`]) === VIEW_ADD) {
        // eslint-disable-next-line no-extra-parens
        content = (
          <div>
            <AddParticipant onDismiss={this.handleAddPeopleDismiss} />
          </div>
        );
      }
      else {
        let addPeopleDisplay;
        if (canEditRoster) {
          // eslint-disable-next-line no-extra-parens
          addPeopleDisplay = (
            // eslint-disable-reason false positive until a11y plugin upgraded to ^5.0
            // eslint-disable-next-line jsx-a11y/no-static-element-interactions
            <div
              className={classNames(`ciscospark-roster-add-people`, styles.addPeople)}
              onClick={this.handleAddPeople}
              onKeyPress={this.handleAddPeople}
              role="button"
              tabIndex="0"
            >
              <div className={classNames(styles.addPeopleIcon)}>
                <Icon type={ICON_TYPE_ADD} />
              </div>
              <div>
                {formatMessage(messages.addPeople)}
              </div>
            </div>
          );
        }
        let moderators;
        if (participantsModerators && participantsModerators.length) {
          // eslint-disable-next-line no-extra-parens
          moderators = (
            <div>
              <div className={classNames(`ciscospark-roster-participants-separator`, styles.participantsSeparator)}>
                {formatMessage(messages.moderators)}
              </div>
              <div><ParticipantList participants={participantsModerators} /></div>
            </div>
          );
        }
        // eslint-disable-next-line no-extra-parens
        content = (
          <div>
            {
              addPeopleDisplay
            }
            <div><ParticipantList participants={participantsCurrentUser} /></div>
            {
              moderators
            }
            <div className={classNames(`ciscospark-roster-participants-separator`, styles.participantsSeparator)}>
              {formatMessage(messages.participants)}
            </div>
            <div><ParticipantList participants={participantsOther} /></div>
          </div>
        );
      }

      // eslint-disable-next-line no-extra-parens
      mainArea = (
        <div>
          {
            hasExternalParticipants && <ExternalParticipantMessage message={formatMessage(messages.externalParticipants)} />
          }
          {content}
        </div>
      );
    }
    return (
      <div className={classNames(`ciscospark-roster`, styles.roster)}>
        <div className={classNames(`ciscospark-roster-header`, styles.rosterHeader)}>
          <div className={classNames(`ciscospark-roster-close`, styles.rosterClose)}>
            <div className={classNames(`ciscospark-roster-close-button`, styles.rosterCloseButton)}>
              <Button accessibilityLabel={`Close`} iconType={ICON_TYPE_EXIT} onClick={this.handleCloseClick} />
            </div>
          </div>
          <div className={classNames(`ciscospark-roster-title`, styles.rosterTitle)}>
            {`People ${participantCountDisplay}`}
          </div>
          <div className={classNames(`ciscospark-roster-menu`, styles.rosterMenu)}>
            <div className={classNames(`ciscospark-activity-menu-button`, styles.activityMenuButton)}>
              <Button accessibilityLabel={`Main Menu`} iconType={ICON_TYPE_WAFFLE} onClick={this.handleMenuClick} />
            </div>
          </div>
        </div>
        <div className={classNames(`ciscospark-roster-scrolling-list`, styles.scrolling)} >
          {mainArea}
        </div>
      </div>
    );
  }
}

const injectedPropTypes = {
  canEditRoster: PropTypes.bool.isRequired,
  conversation: PropTypes.object.isRequired,
  hasExternalParticipants: PropTypes.bool.isRequired,
  participants: PropTypes.array.isRequired,
  participantsCurrentUser: PropTypes.array.isRequired,
  participantsModerators: PropTypes.array,
  participantsOther: PropTypes.array.isRequired,
  sparkInstance: PropTypes.object,
  user: PropTypes.object.isRequired,
  widgetRoster: PropTypes.object.isRequired,
  setWidgetViewAdd: PropTypes.func.isRequired,
  setWidgetViewMain: PropTypes.func.isRequired
};

export const ownPropTypes = {
  onClickClose: PropTypes.func,
  onClickMenu: PropTypes.func,
  onEvent: PropTypes.func,
  spaceId: PropTypes.string,
  eventNames: PropTypes.object
};

RosterWidget.propTypes = {
  ...ownPropTypes,
  ...injectedPropTypes
};

export default connect(
  getRosterWidgetProps,
  (dispatch) => bindActionCreators({
    fetchAvatarsForUsers,
    setWidgetViewAdd,
    setWidgetViewMain
  }, dispatch)
)(RosterWidget);
