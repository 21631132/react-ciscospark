import {Component} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import _ from 'lodash';

import browserUtilities from './browserUtils';
import getNotificationDetails from './selectors';
import {
  notificationSent,
  setNotificationPermission,
  setNotificationSupported
} from './actions';
import {
  eventNames,
  constructNotificationEventData
} from './events';


const TIMEOUT_LENGTH = 10000;

export class Notifications extends Component {
  componentDidMount() {
    const {props} = this;
    // Default state is not supported, once we know it is, don't check any more
    this.setup(props);
  }

  shouldComponentUpdate(nextProps) {
    const {props} = this;
    return nextProps.notifications !== props.notifications
      || nextProps.isSupported !== props.isSupported
      || nextProps.permission !== props.permission;
  }

  componentDidUpdate() {
    this.setup(this.props);
    this.displayNotifications();
  }

  /**
   * Check for permissions and support
   *
   * @param {object} props
   * @returns null
   */

  setup(props) {
    if (!props.isSupported) {
      this.checkSupported();
    }
    if (_.isNull(props.permission) && props.isSupported) {
      this.requestPermission();
    }
  }

  /**
   * Requests permission from the browser to allow notifications
   *
   * @returns {Promise}
   */
  requestPermission() {
    const {props} = this;
    return browserUtilities.requestPermissionForNotifications(
      (permission) => props.setNotificationPermission(permission)
    );
  }

  /**
   * Checks if browser notifications are supported and updates store
   *
   * @returns {null}
   */
  checkSupported() {
    const {props} = this;
    if (!props.isSupported && browserUtilities.isNotificationSupported()) {
      props.setNotificationSupported(true);
    }
  }

  /**
   * Processes notifications and displays them if needed
   *
   * @returns {null}
   */
  displayNotifications() {
    const {props} = this;
    const hasPermission = props.permission === browserUtilities.PERMISSION_GRANTED;
    if (props.notifications.count() > 0) {
      props.notifications.forEach((notification) => {
        const {
          username, message, avatar, notificationId
        } = notification;
        if (hasPermission && browserUtilities.isBrowserHidden()) {
          // Actually display notification
          const n = browserUtilities.spawnNotification(message, avatar, username, TIMEOUT_LENGTH);
          // If there is an onEvent method
          const details = constructNotificationEventData(n, notification);
          if (props.onEvent && typeof props.onEvent === 'function') {
            props.onEvent(eventNames.NOTIFICATIONS_CREATED, details);
            n.addEventListener('click', () => {
              props.onEvent(eventNames.NOTIFICATIONS_CLICKED, details);
            });
          }
        }
        props.notificationSent(notificationId);
      });
    }
  }

  render() {
    return null;
  }
}

export default connect(
  getNotificationDetails,
  (dispatch) => bindActionCreators({
    notificationSent,
    setNotificationPermission,
    setNotificationSupported
  }, dispatch)
)(Notifications);
