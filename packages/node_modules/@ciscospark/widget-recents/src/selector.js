import {createSelector} from 'reselect';
import moment from 'moment';
import {OrderedMap} from 'immutable';
import {formatDate} from '@ciscospark/react-component-utils';

const getWidget = (state) => state.widgetRecents;
const getSpark = (state) => state.spark;
const getUsers = (state) => state.user;
const getAvatars = (state) => state.avatar;
const getSpaces = (state) => state.spaces;
const getMedia = (state) => state.media;
const getTeams = (state) => state.teams;


function constructSpace(space, avatarUrl) {

  const lastSeenActivityDate = space.get(`lastSeenActivityDate`);
  const lastActivityTimestamp = space.get(`lastReadableActivityDate`);
  const isUnread = lastSeenActivityDate ? moment(lastSeenActivityDate).isBefore(lastActivityTimestamp) : true;

  const id = space.get(`id`);
  const actorName = space.getIn([`latestActivity`, `actor`, `displayName`]);

  return {
    id,
    type: space.get(`type`),
    lastActivityTime: formatDate(lastActivityTimestamp),
    lastActivityTimestamp,
    latestActivity: {
      actorName: actorName ? actorName.split(` `)[0] : ``,
      type: space.getIn([`latestActivity`, `verb`]),
      object: space.getIn([`latestActivity`, `object`]).toJS(),
      text: space.getIn([`latestActivity`, `object`, `displayName`])
    },
    avatarUrl,
    participants: space.get(`participants`).toJS(),
    published: space.get(`published`),
    isLocked: space.get(`tags`) && space.get(`tags`).includes(`LOCKED`),
    isUnread
  };
}

function constructOneOnOne(space, currentUser, avatars) {
  // Get the user ID of the participant that isn't current user
  let avatarUrl;
  let toPersonEmail;
  const otherUser = space.get(`participants`).find((p) => p.get(`id`) !== currentUser.id);
  if (otherUser) {
    const otherUserId = otherUser.get(`id`);
    avatarUrl = avatars.get(otherUserId);
    toPersonEmail = otherUser.get(`emailAddress`);
  }
  const thisSpace = constructSpace(space, avatarUrl);
  if (toPersonEmail) {
    thisSpace.toPersonEmail = toPersonEmail;
  }
  const currentUserEmail = currentUser.email;
  const otherUsers = space.get(`participants`)
    .find((p) => p.get(`emailAddress`) !== currentUserEmail);
  if (otherUsers) {
    thisSpace.name = otherUsers.get(`displayName`);
  }
  else if (space.get(`displayName`)) {
    thisSpace.name = space.get(`displayName`);
  }
  else {
    thisSpace.name = `Untitled`;
  }
  return thisSpace;
}

function constructGroup(space, avatars, team) {
  const id = space.get(`id`);
  const avatarUrl = avatars.get(id);
  const thisSpace = constructSpace(space, avatarUrl);
  if (space.get(`displayName`)) {
    thisSpace.name = space.get(`displayName`);
  }
  else {
    thisSpace.name = `Untitled`;
  }
  if (team) {
    thisSpace.teamName = team.get(`displayName`);
    thisSpace.teamColor = team.get(`teamColor`);
    thisSpace.teamId = team.get(`id`);
    if (id === team.get(`generalConversationUuid`)) {
      thisSpace.name = `General`;
    }
  }
  return thisSpace;
}

const getRecentSpaces = createSelector(
  [getSpaces, getUsers, getAvatars, getTeams],
  (spaces, users, avatars, teams) => { // eslint-disable-line max-params
    const currentUser = users.get(`currentUser`);
    const avatarItems = avatars.get(`items`);
    let recents = new OrderedMap();
    spaces.get(`items`).forEach((space) => {
      if (!space.get(`hidden`)) {
        const spaceId = space.get(`id`);
        const team = teams.getIn([`items`, space.getIn([`team`, `id`])]);
        if (space.get(`type`) === `direct`) {
          recents = recents.set(spaceId, constructOneOnOne(space, currentUser, avatarItems));
        }
        else {
          recents = recents.set(spaceId, constructGroup(space, avatarItems, team));
        }
      }
    });
    return recents.sortBy(sortByNewest);
  }
);


function sortByNewest(space) {
  return -moment(space.lastActivityTimestamp).format(`x`);
}

export const getRecentsWidgetProps = createSelector(
  [getWidget, getUsers, getAvatars, getSpaces, getRecentSpaces, getSpark, getMedia, getTeams],
  (widget, user, avatar, spaces, spacesList, spark, media, teams) => ({ // eslint-disable-line max-params
    widgetRecent: widget,
    sparkState: spark.get(`status`),
    sparkInstance: spark.get(`spark`),
    user,
    avatar,
    spaces,
    spacesList,
    media,
    teams
  })
);
