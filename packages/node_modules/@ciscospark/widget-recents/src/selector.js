/* eslint-disable max-params */

import {createSelector} from 'reselect';
import moment from 'moment';
import {OrderedMap} from 'immutable';
import {formatDate} from '@ciscospark/react-component-utils';

const getWidget = (state) => state.widgetRecents;
const getSpark = (state) => state.spark;
const getUsers = (state) => state.user;
const getAvatars = (state) => state.avatar;
const getSpaces = (state) => state.spaces;
const getMedia = (state) => state.media;
const getTeams = (state) => state.teams;


function constructSpace(space) {

  const lastSeenActivityDate = space.get(`lastSeenActivityDate`);
  const lastActivityTimestamp = space.get(`lastReadableActivityDate`);
  const isUnread = lastSeenActivityDate ? moment(lastSeenActivityDate).isBefore(lastActivityTimestamp) : true;

  const id = space.get(`id`);
  const actorName = space.getIn([`latestActivity`, `actor`, `displayName`]);

  return {
    id,
    type: space.get(`type`),
    lastActivityTime: formatDate(lastActivityTimestamp),
    lastActivityTimestamp,
    latestActivity: {
      actorName: actorName ? actorName.split(` `)[0] : ``,
      type: space.getIn([`latestActivity`, `verb`]),
      object: space.getIn([`latestActivity`, `object`]).toJS(),
      text: space.getIn([`latestActivity`, `object`, `displayName`])
    },
    participants: space.get(`participants`).toJS(),
    published: space.get(`published`),
    isLocked: space.get(`tags`) && space.get(`tags`).includes(`LOCKED`),
    isUnread,
    isDecrypting: space.get(`isDecrypting`)
  };
}

function constructOneOnOne(space, currentUser) {
  const thisSpace = constructSpace(space);

  // Get the user ID of the participant that isn't current user
  const toPerson = space.get(`participants`).find((p) => p.get(`id`) !== currentUser.id);
  if (toPerson) {
    thisSpace.toPersonId = toPerson.get(`id`);
    thisSpace.toPersonEmail = toPerson.get(`emailAddress`);
  }

  const currentUserEmail = currentUser.email;
  const otherUsers = space.get(`participants`)
    .find((p) => p.get(`emailAddress`) !== currentUserEmail);
  if (otherUsers) {
    thisSpace.name = otherUsers.get(`displayName`);
  }
  else if (space.get(`displayName`)) {
    thisSpace.name = space.get(`displayName`);
  }
  else {
    thisSpace.name = `Untitled`;
  }
  return thisSpace;
}

function constructGroup(space, team) {
  const id = space.get(`id`);
  const thisSpace = constructSpace(space);
  if (space.get(`displayName`)) {
    thisSpace.name = space.get(`displayName`);
  }
  else {
    thisSpace.name = `Untitled`;
  }
  if (team) {
    thisSpace.teamName = team.get(`displayName`);
    thisSpace.teamColor = team.get(`teamColor`);
    thisSpace.teamId = team.get(`id`);
    if (id === team.get(`generalConversationUuid`)) {
      thisSpace.name = `General`;
    }
  }
  return thisSpace;
}

const getRecentSpaces = createSelector(
  [getSpaces, getUsers, getTeams, getWidget],
  (spaces, users, teams, widget) => {
    const visibilityCount = widget.get(`visibilityCount`);
    const currentUser = users.get(`currentUser`);
    let recents = new OrderedMap();
    let count = 0;
    spaces.get(`items`).toOrderedMap().sortBy(sortByNewest).some((space) => {
      if (!space.get(`hidden`)) {
        const spaceId = space.get(`id`);
        const team = teams.getIn([`items`, space.getIn([`team`, `id`])]);
        if (space.get(`type`) === `direct`) {
          recents = recents.set(spaceId, constructOneOnOne(space, currentUser));
        }
        else {
          recents = recents.set(spaceId, constructGroup(space, team));
        }
        count = count + 1;
      }
      if (count >= visibilityCount) {
        return true;
      }
      return false;
    });
    return recents;
  }
);


const getRecentSpacesWithAvatarUrl = createSelector(
  [getRecentSpaces, getAvatars],
  (recentSpaces, avatars) => {
    const avatarItems = avatars.get(`items`);
    if (avatarItems.count()) {
      return recentSpaces.map((s) => {
        if (s.type === `direct`) {
          s.avatarUrl = avatarItems.get(s.toPersonId);
        }
        else {
          s.avatarUrl = avatarItems.get(s.id);
        }
        return s;
      });
    }
    return recentSpaces;
  }
);


function sortByNewest(space) {
  return -moment(space.get(`lastReadableActivityDate`)).format(`x`);
}

export const getRecentsWidgetProps = createSelector(
  [getWidget, getUsers, getSpaces, getRecentSpacesWithAvatarUrl, getSpark, getMedia, getTeams],
  (widget, user, spaces, spacesList, spark, media, teams) => {
    let lastActivityDate;
    if (spacesList && spacesList.count()) {
      lastActivityDate = spacesList.last().lastActivityTimestamp;
    }
    return { // eslint-disable-line max-params
      widgetStatus: widget.get(`status`).toJS(),
      sparkState: spark.get(`status`),
      sparkInstance: spark.get(`spark`),
      lastActivityDate,
      user,
      spaces,
      spacesList,
      media,
      teams
    };
  }
);
