import {createSelector} from 'reselect';
import moment from 'moment';
import {OrderedMap} from 'immutable';
import {formatDate} from '@ciscospark/react-component-utils';
import {FEATURE_GROUP_CALLING} from '@ciscospark/redux-module-features';

const getAvatars = (state) => state.avatar;
const getCurrentUser = (state, ownProps) => ownProps.currentUser;
const getFeatures = (state) => state.features;
const getCalls = (state) => state.media.get('calls');
const getSpaces = (state) => state.spaces;
const getSpark = (state) => state.spark;
const getTeams = (state) => state.teams;
const getUsers = (state) => state.users;
const getWidget = (state) => state.widgetRecents;


function sortByNewest(space) {
  return -moment(space.get('lastReadableActivityDate')).format('x');
}

function constructSpace(space) {
  const lastSeenActivityDate = space.get('lastSeenActivityDate');
  const lastActivityTimestamp = space.get('lastReadableActivityDate');
  const isUnread = lastSeenActivityDate ? moment(lastSeenActivityDate).isBefore(lastActivityTimestamp) : true;

  const id = space.get('id');
  const actorName = space.getIn(['latestActivity', 'actor', 'displayName']);

  return {
    id,
    type: space.get('type'),
    lastActivityTime: formatDate(lastActivityTimestamp),
    lastActivityTimestamp,
    name: 'Untitled',
    latestActivity: {
      actorName: actorName ? actorName.split(' ')[0] : '',
      actor: space.getIn(['latestActivity', 'actor']).toJS(),
      type: space.getIn(['latestActivity', 'verb']),
      object: space.getIn(['latestActivity', 'object']).toJS(),
      text: space.getIn(['latestActivity', 'object', 'displayName'])
    },
    participants: space.get('participants').toJS(),
    published: space.get('published'),
    isLocked: space.get('tags') && space.get('tags').includes('LOCKED'),
    isUnread,
    isDecrypting: space.get('isDecrypting')
  };
}

function constructOneOnOne({space, currentUser, users}) {
  const thisSpace = constructSpace(space);

  // Get the user ID of the participant that isn't current user
  const toPersonId = space.get('participants').find((p) => p !== currentUser.id);
  const toPerson = users.getIn(['byId', toPersonId]);
  if (toPerson) {
    thisSpace.toPersonId = toPersonId;
    thisSpace.toPersonEmail = toPerson.email;
    thisSpace.name = toPerson.displayName;
  }
  return thisSpace;
}

function constructGroup({space, team}) {
  const id = space.get('id');
  const thisSpace = constructSpace(space);
  thisSpace.name = space.get('displayName') || 'Untitled';
  if (team) {
    thisSpace.teamName = team.get('displayName');
    thisSpace.teamColor = team.get('teamColor');
    thisSpace.teamId = team.get('id');
    if (id === team.get('generalConversationUuid')) {
      thisSpace.name = 'General';
    }
  }
  return thisSpace;
}

const getRecentSpaces = createSelector(
  [getSpaces, getCurrentUser, getUsers, getTeams, getWidget],
  (spaces, currentUser, users, teams, widget) => {
    const visibilityCount = widget.get('visibilityCount');
    let recents = new OrderedMap();
    let count = 0;
    spaces.get('items').toOrderedMap().sortBy(sortByNewest).some((space) => {
      if (!space.get('hidden')) {
        const spaceId = space.get('id');
        const team = teams.getIn(['items', space.getIn(['team', 'id'])]);
        if (space.get('type') === 'direct') {
          recents = recents.set(spaceId, constructOneOnOne({space, users, currentUser}));
        }
        else {
          recents = recents.set(spaceId, constructGroup({space, team}));
        }
        count += 1;
      }
      if (count >= visibilityCount) {
        return true;
      }
      return false;
    });
    return recents;
  }
);


const getRecentSpacesWithAvatarUrl = createSelector(
  [getRecentSpaces, getAvatars],
  (recentSpaces, avatars) => {
    const avatarItems = avatars.get('items');
    if (avatarItems.count()) {
      return recentSpaces.map((space) => {
        const s = space;
        if (s.type === 'direct') {
          s.avatarUrl = avatarItems.get(s.toPersonId);
        }
        else {
          s.avatarUrl = avatarItems.get(s.id);
        }
        return s;
      });
    }
    return recentSpaces;
  }
);

const getIncomingCall = createSelector(
  [getCalls],
  (calls) => calls.find((call) => call.isIncoming && !call.isDismissed)
);

const getRecentsWidgetProps = createSelector(
  [
    getWidget,
    getRecentSpacesWithAvatarUrl,
    getSpark,
    getFeatures,
    getIncomingCall
  ],
  (
    widget,
    spacesList,
    spark,
    features,
    incomingCall
  ) => {
    let lastActivityDate;
    if (spacesList && spacesList.count()) {
      lastActivityDate = spacesList.last().lastActivityTimestamp;
    }
    const hasGroupCalling = features.getIn(['items', FEATURE_GROUP_CALLING]);
    return {
      widgetStatus: widget.get('status').toJS(),
      sparkState: spark.get('status'),
      sparkInstance: spark.get('spark'),
      widgetRecents: widget,
      spacesList,
      hasGroupCalling,
      lastActivityDate,
      incomingCall
    };
  }
);

export default getRecentsWidgetProps;
