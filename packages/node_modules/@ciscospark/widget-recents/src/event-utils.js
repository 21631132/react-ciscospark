import {base64} from '@ciscospark/common';


/**
 * Constructs an event detail object for messages:created
 * @export
 * @param {Object} activity from mercury
 * @param {Object} toUser
 * @returns {Object} constructed event
 */
export function constructMessagesEventData(activity, toUser) {
  const roomType = activity.target.tags.includes(`ONE_ON_ONE`) ? `direct` : `group`;
  let files, toPersonEmail, toPersonId;

  if (roomType === `direct` && toUser) {
    toPersonEmail = toUser.emailAddress;
    toPersonId = constructHydraId(`PEOPLE`, toUser.id);
  }

  let mentionedPeople = activity.object.mentions;
  if (mentionedPeople && mentionedPeople.items.length) {
    mentionedPeople = mentionedPeople.items.map((people) => ({
      id: constructHydraId(`PEOPLE`, people.id)
    }));
  }

  // Files need to be decrypted and converted into a usable URL
  if (activity.object.files && activity.object.files.items.length) {
    files = activity.object.files.items;
  }

  const personId = constructHydraId(`PEOPLE`, activity.actor.id);
  return {
    actorId: personId,
    id: constructHydraId(`MESSAGE`, activity.id),
    roomId: constructHydraId(`ROOM`, activity.target.id),
    roomType: activity.target.tags.includes(`ONE_ON_ONE`) ? `direct` : `group`,
    text: activity.object.displayName,
    html: activity.object.content,
    files,
    personId,
    personEmail: activity.actor.emailAddress,
    created: activity.published,
    mentionedPeople,
    toPersonId,
    toPersonEmail
  };
}


export function constructRoomsEventData(activity, space) {
  return {
    actorId: constructHydraId(`PEOPLE`, activity.actor.id),
    id: constructHydraId(`ROOM`, space.id),
    title: space.name,
    type: space.type,
    teamId: space.teamId,
    lastActivity: activity.published,
    created: space.published
  };
}

function constructHydraId(type, id) {
  return base64.encode(`ciscospark://us/${type.toUpperCase()}/${id}`);
}
