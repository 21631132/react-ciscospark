import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Spinner from '@ciscospark/react-component-spinner';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {
  acknowledgeSpace,
  fetchSpace,
  fetchSpaceAvatar,
  removeSpace,
  initialFetchSpaces,
  updateSpaceWithActivity
} from '@ciscospark/redux-module-spaces';
import {connectToMercury} from '@ciscospark/redux-module-mercury';

import messages from './messages';
import {getRecentsWidgetProps} from './selector';
import {
  updateWidgetStatus
} from './actions';
import SpacesList from './components/spaces-list';
import styles from './styles.css';
import {
  eventNames,
  constructMessagesEventData,
  constructRoomsEventData,
  constructMembershipEventData,
  constructCallEventData
} from './events';

export class RecentsWidget extends Component {

  componentWillReceiveProps(nextProps) {
    this.setup(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.sparkInstance.mercury.disconnect().then(() => this.props.removeWidget());
  }

  @autobind
  setup(props) { // eslint-disable-line complexity
    const {
      sparkInstance,
      sparkState,
      mercury,
      user,
      spaces,
      widgetRecents
    } = props;

    if (sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`)) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`])
        && !mercury.getIn([`status`, `connecting`])
        && !mercury.getIn([`status`, `connected`])
        && sparkInstance.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      // Grab spaces
      if (!spaces.getIn([`status`, `isFetching`])
        && mercury.getIn([`status`, `connected`])
        && !spaces.get(`items`).count()) {
        props.initialFetchSpaces(sparkInstance);
      }

      if (user.get(`currentUser`)
        && spaces.getIn(`status`, `hasFetched`)) {
        if (!widgetRecents.getIn([`status`, `isListeningForNewActivity`])) {
          this.listenForNewActivity(sparkInstance, props);
          this.listenForCall(sparkInstance, props);
        }
        spaces.get(`items`).forEach((s) => {
          if (!spaces.getIn([`avatars`, s.get(`id`)])) {
            props.fetchSpaceAvatar(sparkInstance, s.toJS());
          }
        });
      }
    }
  }

  @autobind
  handleNewActivity(activity) {
    const {
      props
    } = this;
    const {
      sparkInstance,
      spacesList
    } = props;
    const spaceId = activity.target.id;
    const space = spacesList.get(spaceId);

    const processActivity = this.processActivity;
    if (space) {
      processActivity(activity, space);
    }
    else {
      // go retrieve the space if it doesn't exist
      props.fetchSpace(sparkInstance, spaceId)
        .then((newSpace) => {
          if (newSpace) {
            processActivity(activity, newSpace);
          }
        });
    }
  }

  @autobind
  processActivity(activity, space) { // eslint-disable-line complexity
    const {props, handleEvent} = this;
    const {
      user
    } = props;
    const currentUser = user.get(`currentUser`);
    const isSelf = activity.actor.id === currentUser.id;
    switch (activity.verb) {
    case `share`:
    case `post`: {
      const currentUserEmail = currentUser.email;
      const otherUser = space.participants
        .find((p) => p.emailAddress !== currentUserEmail);

      // Update space with newest post activity
      props.updateSpaceWithActivity(activity, isSelf, true);

      // Do not emit unread if current user created the message
      if (!isSelf) {
        handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
      }
      // Emit message:created event
      handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser));
      break;
    }
    case `lock`:
    case `unlock`: {
      props.updateSpaceWithActivity(activity, isSelf);
      break;
    }
    case `acknowledge`: {
      if (isSelf) {
        // update space with last acknowledgment if it's this user
        props.updateSpaceWithActivity(activity, isSelf);
        handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
      }
      break;
    }
    case `add`: {
      handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity));
      break;
    }
    case `leave`: {
      props.removeSpace(space.id);
      handleEvent(eventNames.MEMBERSHIPS_DELETED, constructMembershipEventData(activity));
      break;
    }
    default:
    }
  }

  /**
   * Setup listeners for new activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForNewActivity(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForNewActivity: true});
    return sparkInstance.mercury.on(`event:conversation.activity`, (event) => this.handleNewActivity(event.data.activity));
  }

  /**
   * Setup listeners for call activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForCall(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForCall: true});
    return sparkInstance.phone.on(`call:incoming`, (call) => this.handleCall(call));
  }

  @autobind
  handleCall(call) {
    const {
      spacesList
    } = this.props;

    const space = spacesList.get(call.locus.conversationUrl.split(`/`).pop());
    this.handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  @autobind
  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }


    /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undfined}
   */
  @autobind
  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    sparkInstance.logger.info(`event handler - ${name} - ${data.action}`, data);
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  render() {
    const props = this.props;
    const {
      spacesList,
      spaces
    } = props;
    const {formatMessage} = props.intl;
    const isFetchingSpaces = spaces.getIn([`status`, `isFetching`]);
    if (spacesList && spacesList.count()) {
      return (
        <div className={classNames(`ciscospark-spaces-list-wrapper`, styles.spacesListWrapper)}>
          <SpacesList
            formatMessage={formatMessage}
            onCallClick={this.handleSpaceCallClick}
            onClick={this.handleSpaceClick}
            spaces={spacesList}
          />
          {
            isFetchingSpaces &&
            <div className={styles.spinner}>
              <Spinner />
            </div>
          }
        </div>
      );
    }
    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  mercury: PropTypes.object,
  sparkInstance: PropTypes.object,
  eventNames: PropTypes.object,
  user: PropTypes.object,
  spaces: PropTypes.object,
  spacesList: PropTypes.object,
  widgetRecents: PropTypes.object,
  connectToMercury: PropTypes.func,
  updateWidgetStatus: PropTypes.func
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool
};

RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};


function mapStateToProps(state) {
  return getRecentsWidgetProps(state);
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    acknowledgeSpace,
    connectToMercury,
    fetchCurrentUser,
    fetchSpace,
    fetchSpaceAvatar,
    removeSpace,
    initialFetchSpaces,
    updateWidgetStatus,
    updateSpaceWithActivity
  }, dispatch)
)(RecentsWidget);
