import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import LoadingScreen from '@ciscospark/react-component-loading-screen';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {
  acknowledgeSpace,
  fetchSpace,
  fetchSpaces,
  updateSpaceWithActivity
} from '@ciscospark/redux-module-spaces';
import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {
  constructMessagesEventData,
  constructRoomsEventData,
  constructMembershipEventData
} from './event-utils';

import messages from './messages';
import {getRecentsWidgetProps} from './selector';
import {updateWidgetStatus} from './actions';
import SpacesList from './components/spaces-list';
import styles from './styles.css';
import eventNames from './event-names';


export class RecentsWidget extends Component {

  componentWillReceiveProps(nextProps) {
    this.setup(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.sparkInstance.mercury.disconnect().then(() => this.props.removeWidget());
  }

  @autobind
  setup(props) { // eslint-disable-line complexity
    const {
      sparkInstance,
      sparkState,
      mercury,
      metrics,
      user,
      spaces,
      spacesList,
      widgetRecents
    } = props;

    if (sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`)) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`])
        && !mercury.getIn([`status`, `connecting`])
        && !mercury.getIn([`status`, `connected`])
        && sparkInstance.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      // Grab spaces
      if (!spaces.getIn([`status`, `isFetching`])
        && mercury.getIn([`status`, `connected`])
        && !spaces.get(`items`).count()) {
        props.fetchSpaces(sparkInstance);
      }

      if (!widgetRecents.getIn([`status`, `isListeningForNewActivity`])
        && user.get(`currentUser`)
        && spaces.getIn(`status`, `hasFetched`)
        ) {
        this.listenForNewActivity(sparkInstance, props);
      }
    }
    if (spacesList.count()) {
      metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
    }
  }

  @autobind
  handleNewActivity(activity) { // eslint-disable-line complexity
    const {props, handleEvent} = this;
    const {
      sparkInstance,
      spacesList,
      user
    } = props;
    const spaceId = activity.target.id;
    const space = spacesList.get(spaceId);
    const currentUser = user.get(`currentUser`);
    const isSelf = activity.actor.id === currentUser.id;
    switch (activity.verb) {
    case `share`:
    case `post`: {
      if (space) {
        const currentUserEmail = currentUser.email;
        const otherUser = space.participants
          .find((p) => p.emailAddress !== currentUserEmail);

        // Update space with newest post activity
        props.updateSpaceWithActivity(activity, isSelf);

        // Do not emit unread if current user created the message
        if (!isSelf) {
          handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
        }
        // Emit message:created event
        handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser));
      }
      else {
        // go retrieve the space if it doesn't exist
        props.fetchSpace(sparkInstance, spaceId);
      }
      break;
    }
    case `lock`:
    case `unlock`: {
      if (space) {
        props.updateSpaceWithActivity(activity, isSelf);
      }
      break;
    }
    case `acknowledge`: {
      if (isSelf && space) {
        // update space with last acknowledgment if it's this user
        props.acknowledgeSpace(activity);
        handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
      }
      break;
    }
    case `add`: {
      // Handle adding this user to a space
      // get space id, and check if it's been retrieved
      // If not, get space details and add to spacesList
      // Fire off dom event handler

      // Handle adding another user to a space
      if (isSelf && space) {
        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity));
      }
      // fire off dom event handler
      break;
    }
    default:
    }
  }

  /**
   * Setup listeners for new activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {undefined}
   */
  listenForNewActivity(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForNewActivity: true});
    sparkInstance.mercury.on(`event:conversation.activity`, (event) => this.handleNewActivity(event.data.activity));
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

    /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undfined}
   */
  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  render() {
    const props = this.props;
    const {
      spacesList
    } = props;
    const {formatMessage} = props.intl;
    if (spacesList && spacesList.count()) {
      return (
        <div className={classNames(`ciscospark-spaces-list-wrapper`, styles.spacesListWrapper)}>
          <SpacesList formatMessage={formatMessage} onClick={this.handleSpaceClick} spaces={spacesList} />
        </div>
      );
    }
    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  mercury: PropTypes.object,
  sparkInstance: PropTypes.object,
  eventNames: PropTypes.object,
  user: PropTypes.object,
  spaces: PropTypes.object,
  spacesList: PropTypes.object,
  widgetRecents: PropTypes.object,
  connectToMercury: PropTypes.func,
  updateWidgetStatus: PropTypes.func,
  metrics: PropTypes.object
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool
};

RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};


function mapStateToProps(state) {
  return getRecentsWidgetProps(state);
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    acknowledgeSpace,
    connectToMercury,
    fetchCurrentUser,
    fetchSpace,
    fetchSpaces,
    updateWidgetStatus,
    updateSpaceWithActivity
  }, dispatch)
)(RecentsWidget);
