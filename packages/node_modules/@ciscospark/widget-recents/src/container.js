import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';
import {compose} from 'recompose';
import {has} from 'lodash';

import {enhancer as mediaEnhancer} from '@ciscospark/redux-module-media';
import {
  fetchSpace,
  removeSpace,
  updateSpaceWithActivity,
  updateSpaceRead
} from '@ciscospark/redux-module-spaces';
import {storeActivities} from '@ciscospark/redux-module-activities';
import {getFeature} from '@ciscospark/redux-module-features';

import LoadingScreen from '@webex/react-component-loading-screen';
import ErrorDisplay from '@ciscospark/react-component-error-display';
import SpacesList from '@webex/react-component-spaces-list';
import {SearchInput} from '@collab-ui/react';

import enhancers from './enhancers';
import messages from './messages';
import getRecentsWidgetProps from './selector';
import {updateSpaceKeywordFilter, updateWidgetStatus} from './actions';

import styles from './styles.css';
import './collab.scss';

import {
  eventNames,
  constructMessagesEventData,
  constructRoomsEventData,
  constructMembershipEventData,
  constructCallEventData
} from './events';

const injectedPropTypes = {
  errors: PropTypes.object.isRequired,
  incomingCall: PropTypes.object,
  media: PropTypes.object.isRequired,
  mercuryStatus: PropTypes.object.isRequired,
  spacesById: PropTypes.object.isRequired,
  spacesList: PropTypes.object.isRequired,
  spacesListArray: PropTypes.array.isRequired,
  sparkInstance: PropTypes.object,
  sparkState: PropTypes.object.isRequired,
  users: PropTypes.object.isRequired,
  teams: PropTypes.object.isRequired,
  widgetRecents: PropTypes.object.isRequired,
  widgetStatus: PropTypes.object.isRequired,
  addError: PropTypes.func.isRequired,
  features: PropTypes.object.isRequired,
  fetchAvatar: PropTypes.func.isRequired,
  fetchSpace: PropTypes.func.isRequired,
  getFeature: PropTypes.func.isRequired,
  removeSpace: PropTypes.func.isRequired,
  updateSpaceRead: PropTypes.func.isRequired,
  updateSpaceWithActivity: PropTypes.func.isRequired,
  updateSpaceKeywordFilter: PropTypes.func.isRequired,
  updateWidgetStatus: PropTypes.func.isRequired
};

export const ownPropTypes = {
  enableSpaceListFilter: PropTypes.bool,
  muteNotifications: PropTypes.bool,
  spaceTypeFilter: PropTypes.string
};

const defaultProps = {
  enableSpaceListFilter: true,
  spaceTypeFilter: null
};

export class RecentsWidget extends Component {
  componentWillReceiveProps(nextProps) {
    this.addListeners(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.spacesList !== this.props.spacesList
      || nextProps.errors !== this.props.errors
      || nextProps.widgetRecents !== this.props.widgetRecents
      || nextProps.incomingCall !== this.props.incomingCall;
  }

  @autobind
  getSpaceFromCall(call) {
    if (call.instance.locus && call.instance.locus.conversationUrl) {
      return this.props.spacesById.get(call.instance.locus.conversationUrl.split('/').pop());
    }

    return '';
  }

  @autobind
  addListeners(nextProps) {
    const {
      currentUser,
      sparkInstance,
      widgetStatus,
      incomingCall
    } = nextProps;

    if (currentUser
      && !widgetStatus.isListeningForNewActivity
    ) {
      this.listenForNewActivity(sparkInstance, nextProps);
    }
    if (incomingCall && !this.props.incomingCall) {
      this.handleCall(incomingCall.instance);
    }
  }

  @autobind
  handleNewActivity(activity) {
    const {
      props,
      processActivity
    } = this;
    const {
      sparkInstance,
      spacesById
    } = props;

    let spaceId = activity.target && activity.target.id;

    // On delete, refetch space to get previous activity
    if (spaceId && ['delete', 'tombstone'].includes(activity.verb)) {
      props.fetchSpace(sparkInstance, spaceId);
    }

    // Handle spaceId if this is a completely new space or hiding a space
    if (!spaceId && ['create', 'hide'].includes(activity.verb)) {
      spaceId = activity.object.id;
    }

    const space = spacesById.get(spaceId);

    if (space) {
      processActivity(activity, space);
    }
    else {
      // go retrieve the space if it doesn't exist
      props.fetchSpace(sparkInstance, spaceId)
        .then((newSpace) => {
          if (newSpace) {
            processActivity(activity, newSpace);
          }
        });
    }
  }

  @autobind
  processActivity(activity, space) {
    const {props, handleEvent} = this;
    const {
      currentUser,
      users,
      spacesList
    } = props;

    props.storeActivities([activity]);
    const isSelf = activity.actor.id === currentUser.id;
    const formattedSpace = spacesList.get(space.id);

    switch (activity.verb) {
      case 'share':
      case 'post': {
        const currentUserEmail = currentUser.email;
        const otherUserId = !!space.participants && typeof space.participants.find === 'function' && space.participants
          .find((p) => p.emailAddress !== currentUserEmail);
        const otherUser = users.getIn(['byId', otherUserId]);

        // Update space with newest post activity
        props.updateSpaceWithActivity(activity, isSelf, true);

        // Do not emit unread if current user created the message
        if (!isSelf && formattedSpace) {
          handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(formattedSpace, activity));
        }
        // Emit message:created event
        handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser));
        break;
      }
      case 'lock':
      case 'unlock': {
        props.updateSpaceWithActivity(activity, isSelf);
        break;
      }
      case 'acknowledge': {
        if (isSelf && formattedSpace) {
        // update space with last acknowledgment if it's this user
          props.updateSpaceRead(activity.target.id, activity.published);
          handleEvent(eventNames.SPACES_READ, constructRoomsEventData(formattedSpace, activity));
        }
        break;
      }
      case 'create': {
        const constructedActivity = Object.assign({}, activity, {
          target: activity.object,
          object: {
            id: currentUser.id,
            emailAddress: currentUser.email
          }
        });

        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(constructedActivity));
        break;
      }
      case 'add': {
        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity));
        break;
      }
      case 'leave': {
        props.removeSpace(space.id);
        handleEvent(eventNames.MEMBERSHIPS_DELETED, constructMembershipEventData(activity));
        break;
      }
      case 'hide': {
        props.removeSpace(space.id);
        break;
      }
      default:
    }
  }

  /**
   * Setup listeners for new activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForNewActivity(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForNewActivity: true});

    return sparkInstance.internal.mercury.on('event:conversation.activity',
      (event) => this.handleNewActivity(event.data.activity));
  }

  @autobind
  handleCall(call) {
    const {
      props,
      handleEvent
    } = this;
    const {
      spacesById
    } = props;
    let space;

    if (has(call, 'locus.conversationUrl')) {
      space = spacesById.get(call.locus.conversationUrl.split('/').pop());
    }
    else {
      // We don't know anything about this space for this call
      space = {
        id: call.id
      };
    }

    handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);

    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  @autobind
  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);

    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }


  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undefined}
   */
  @autobind
  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    const logData = Object.assign({}, data);

    // Omit call objet from logger to prevent call range error
    if (data.call) {
      logData.call = '--- OMITTED ---';
    }
    sparkInstance.logger.info(`event handler - ${name}`, logData);
    if (typeof onEvent === 'function') {
      this.props.onEvent(name, data);
    }
  }

  @autobind
  handleSpaceFilterInput(event) {
    const {props} = this;
    const keyword = event.target.value;

    props.updateSpaceKeywordFilter(keyword);
  }

  render() {
    const {props} = this;
    const {
      enableSpaceListFilter,
      errors,
      features,
      keywordFilter,
      spacesListArray,
      currentUser,
      widgetStatus
    } = props;
    const {formatMessage} = props.intl;

    let displaySubtitle, displayTitle, temporary, widgetError;

    if (errors.get('hasError')) {
      widgetError = errors.get('errors').first();
      ({
        displayTitle,
        displaySubtitle,
        temporary
      } = widgetError);
    }

    if (spacesListArray && spacesListArray.length) {
      return (
        <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
          {
            errors.get('hasError') &&
            <div className={classNames('ciscospark-error-wrapper', styles.errorWrapper)}>
              <ErrorDisplay
                secondaryTitle={displaySubtitle}
                title={displayTitle}
                transparent={temporary}
              />
            </div>
          }
          {
            enableSpaceListFilter &&
            <div className={classNames('ciscospark-search-input-wrapper', styles.searchInputWrapper, 'cui--dark')}>
              <div className={classNames('ciscospark-search-input', styles.searchInput)}>
                <SearchInput
                  name="pillSearchInput"
                  htmlId="pillSearchInput"
                  type="pill"
                  inputSize="small-10"
                  onKeyUp={this.handleSpaceFilterInput}
                  onChange={this.handleSpaceFilterInput}
                  clear
                />
              </div>
            </div>
          }
          <div className={classNames('ciscospark-spaces-list-wrapper', styles.spacesListWrapper)}>
            <SpacesList
              currentUser={currentUser}
              features={features}
              formatMessage={formatMessage}
              hasCalling
              isLoadingMore={widgetStatus.hasFetchedAllSpaces}
              onCallClick={this.handleSpaceCallClick}
              onClick={this.handleSpaceClick}
              spaces={spacesListArray}
              searchTerm={typeof keywordFilter === 'string' ? keywordFilter : ''}
            />
          </div>
        </div>
      );
    }
    if (errors.get('hasError')) {
      return (
        <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
          <ErrorDisplay
            secondaryTitle={displaySubtitle}
            title={displayTitle}
            transparent={temporary}
          />
        </div>
      );
    }

    return (
      <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
        <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />
      </div>
    );
  }
}


RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};

RecentsWidget.defaultProps = {...defaultProps};

export default compose(
  connect(
    getRecentsWidgetProps,
    (dispatch) => bindActionCreators({
      fetchSpace,
      getFeature,
      removeSpace,
      updateSpaceRead,
      updateSpaceWithActivity,
      storeActivities,
      updateSpaceKeywordFilter,
      updateWidgetStatus
    }, dispatch)
  ),
  ...enhancers,
  mediaEnhancer
)(RecentsWidget);
