import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';
import {compose} from 'recompose';
import {has} from 'lodash';

import {enhancer as mediaEnhancer} from '@ciscospark/redux-module-media';
import {
  fetchSpace,
  removeSpace,
  updateSpaceWithActivity,
  updateSpaceRead
} from '@ciscospark/redux-module-spaces';
import {storeActivities} from '@ciscospark/redux-module-activities';
import {getFeature} from '@ciscospark/redux-module-features';

import LoadingScreen from '@webex/react-component-loading-screen';
import ErrorDisplay from '@ciscospark/react-component-error-display';
import SpacesList from '@webex/react-component-spaces-list';
import {SearchInput} from '@collab-ui/react';

import enhancers from './enhancers';
import messages from './messages';
import getRecentsWidgetProps from './selector';
import {updateSpaceKeywordFilter, updateWidgetStatus} from './actions';

import styles from './styles.css';
import './collab.scss';

import {
  eventNames,
  constructRoomsEventData,
  constructCallEventData
} from './events';

const injectedPropTypes = {
  errors: PropTypes.object.isRequired,
  incomingCall: PropTypes.object,
  media: PropTypes.object.isRequired,
  mercuryStatus: PropTypes.object.isRequired,
  spacesById: PropTypes.object.isRequired,
  spacesList: PropTypes.object.isRequired,
  spacesListArray: PropTypes.array.isRequired,
  sparkInstance: PropTypes.object,
  sparkState: PropTypes.object.isRequired,
  users: PropTypes.object.isRequired,
  teams: PropTypes.object.isRequired,
  widgetRecents: PropTypes.object.isRequired,
  widgetStatus: PropTypes.object.isRequired,
  addError: PropTypes.func.isRequired,
  features: PropTypes.object.isRequired,
  fetchAvatar: PropTypes.func.isRequired,
  fetchSpace: PropTypes.func.isRequired,
  getFeature: PropTypes.func.isRequired,
  removeSpace: PropTypes.func.isRequired,
  updateSpaceRead: PropTypes.func.isRequired,
  updateSpaceWithActivity: PropTypes.func.isRequired,
  updateSpaceKeywordFilter: PropTypes.func.isRequired,
  updateWidgetStatus: PropTypes.func.isRequired
};

export const ownPropTypes = {
  enableSpaceListFilter: PropTypes.bool,
  extendedLoad: PropTypes.bool,
  muteNotifications: PropTypes.bool,
  spaceLoadCount: PropTypes.number
};

const defaultProps = {
  extendedLoad: true,
  enableSpaceListFilter: true,
  spaceLoadCount: 25
};

export class RecentsWidget extends Component {
  componentWillReceiveProps(nextProps) {
    this.addListeners(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.spacesList !== this.props.spacesList
      || nextProps.errors !== this.props.errors
      || nextProps.widgetRecents !== this.props.widgetRecents
      || nextProps.incomingCall !== this.props.incomingCall;
  }

  @autobind
  getSpaceFromCall(call) {
    if (call.instance.locus && call.instance.locus.conversationUrl) {
      return this.props.spacesById.get(call.instance.locus.conversationUrl.split('/').pop());
    }

    return '';
  }

  @autobind
  addListeners(nextProps) {
    const {
      incomingCall
    } = nextProps;

    if (incomingCall && !this.props.incomingCall) {
      this.handleCall(incomingCall.instance);
    }
  }

  @autobind
  handleCall(call) {
    const {
      props,
      handleEvent
    } = this;
    const {
      spacesById
    } = props;
    let space;

    if (has(call, 'locus.conversationUrl')) {
      space = spacesById.get(call.locus.conversationUrl.split('/').pop());
    }
    else {
      // We don't know anything about this space for this call
      space = {
        id: call.id
      };
    }

    handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);

    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  @autobind
  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);

    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }


  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undefined}
   */
  @autobind
  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    const logData = Object.assign({}, data);

    // Omit call objet from logger to prevent call range error
    if (data.call) {
      logData.call = '--- OMITTED ---';
    }
    sparkInstance.logger.info(`event handler - ${name}`, logData);
    if (typeof onEvent === 'function') {
      this.props.onEvent(name, data);
    }
  }

  @autobind
  handleSpaceFilterInput(event) {
    const {props} = this;
    const keyword = event.target.value;

    props.updateSpaceKeywordFilter(keyword);
  }

  render() {
    const {props} = this;
    const {
      enableSpaceListFilter,
      errors,
      features,
      keywordFilter,
      spacesListArray,
      currentUser,
      widgetStatus
    } = props;
    const {formatMessage} = props.intl;

    let displaySubtitle, displayTitle, temporary, widgetError;

    const isLoadingMore = props.extendedLoad
      ? !widgetStatus.hasFetchedAllSpaces : !widgetStatus.hasFetchedInitialSpaces;

    const showHeader = enableSpaceListFilter;

    if (errors.get('hasError')) {
      widgetError = errors.get('errors').first();
      ({
        displayTitle,
        displaySubtitle,
        temporary
      } = widgetError);
    }

    if (spacesListArray && spacesListArray.length) {
      return (
        <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
          {
            errors.get('hasError') &&
            <div className={classNames('ciscospark-error-wrapper', styles.errorWrapper)}>
              <ErrorDisplay
                secondaryTitle={displaySubtitle}
                title={displayTitle}
                transparent={temporary}
              />
            </div>
          }
          {
            showHeader &&
            <div className={classNames('ciscospark-recents-header', styles.recentsHeader, 'cui--dark')}>
              {
                enableSpaceListFilter &&
                <div className={classNames('ciscospark-search-input', styles.searchInput)}>
                  <SearchInput
                    name="pillSearchInput"
                    htmlId="pillSearchInput"
                    type="pill"
                    inputSize="small-10"
                    onKeyUp={this.handleSpaceFilterInput}
                    onChange={this.handleSpaceFilterInput}
                    clear
                  />
                </div>
              }
            </div>
          }
          <div className={classNames('ciscospark-spaces-list-wrapper', styles.spacesListWrapper)}>
            <SpacesList
              currentUser={currentUser}
              features={features}
              formatMessage={formatMessage}
              hasCalling
              isLoadingMore={isLoadingMore}
              onCallClick={this.handleSpaceCallClick}
              onClick={this.handleSpaceClick}
              spaces={spacesListArray}
              searchTerm={typeof keywordFilter === 'string' ? keywordFilter : ''}
            />
          </div>
        </div>
      );
    }
    if (errors.get('hasError')) {
      return (
        <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
          <ErrorDisplay
            secondaryTitle={displaySubtitle}
            title={displayTitle}
            transparent={temporary}
          />
        </div>
      );
    }

    return (
      <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
        <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />
      </div>
    );
  }
}


RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};

RecentsWidget.defaultProps = {...defaultProps};

export default compose(
  connect(
    getRecentsWidgetProps,
    (dispatch) => bindActionCreators({
      fetchSpace,
      getFeature,
      removeSpace,
      updateSpaceRead,
      updateSpaceWithActivity,
      storeActivities,
      updateSpaceKeywordFilter,
      updateWidgetStatus
    }, dispatch)
  ),
  ...enhancers,
  mediaEnhancer
)(RecentsWidget);
