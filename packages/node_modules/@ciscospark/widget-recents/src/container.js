import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';

import {addError, removeError} from '@ciscospark/redux-module-errors';
import {
  getFeature,
  FEATURE_GROUP_CALLING
} from '@ciscospark/redux-module-features';
import {checkWebRTCSupport, declineIncomingCall, dismissIncomingCall, listenForIncomingCalls} from '@ciscospark/redux-module-media';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {
  acknowledgeSpace,
  fetchSpace,
  hideSpace,
  removeSpace,
  fetchSpaces,
  updateSpaceWithActivity,
  updateSpaceRead
} from '@ciscospark/redux-module-spaces';
import {
  storeActivities
} from '@ciscospark/redux-module-activities';
import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {fetchTeams} from '@ciscospark/redux-module-teams';
import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';

import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Spinner from '@ciscospark/react-component-spinner';
import ErrorDisplay from '@ciscospark/react-component-error-display';
import IncomingCall from '@ciscospark/react-component-incoming-call';

import messages from './messages';
import getRecentsWidgetProps from './selector';
import {
  updateWidgetStatus,
  updateVisibilityCount
} from './actions';
import SpacesList from './components/spaces-list';
import styles from './styles.css';
import {
  eventNames,
  constructMessagesEventData,
  constructRoomsEventData,
  constructMembershipEventData,
  constructCallEventData
} from './events';


const injectedPropTypes = {
  hasGroupCalling: PropTypes.bool,
  errors: PropTypes.object,
  eventNames: PropTypes.object,
  incomingCall: PropTypes.object,
  media: PropTypes.object,
  mercury: PropTypes.object,
  metrics: PropTypes.object,
  spaces: PropTypes.object,
  spacesList: PropTypes.object,
  sparkInstance: PropTypes.object,
  users: PropTypes.object,
  teams: PropTypes.object,
  widgetRecents: PropTypes.object,
  widgetStatus: PropTypes.object,
  addError: PropTypes.func,
  checkWebRTCSupport: PropTypes.func.isRequired,
  connectToMercury: PropTypes.func,
  dismissIncomingCall: PropTypes.func.isRequired,
  declineIncomingCall: PropTypes.func.isRequired,
  fetchAvatar: PropTypes.func,
  listenForIncomingCalls: PropTypes.func.isRequired,
  removeError: PropTypes.func,
  updateWidgetStatus: PropTypes.func
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool
};

export class RecentsWidget extends Component {
  @autobind
  static setup(props) {
    const {
      errors,
      spark,
      sparkInstance,
      sparkState,
      media,
      mercury,
      metrics,
      widgetStatus
    } = props;

    // Check for spark device errors (auth)
    const registerErrorId = 'spark.register';
    if (
      sparkState.get('registerError')
      && (!errors.get('hasError') || !errors.get('errors').has(registerErrorId))
    ) {
      const {formatMessage} = props.intl;
      const error = spark.get('error');
      const displayTitle = formatMessage(messages.unableToLoad);
      let displaySubtitle = formatMessage(messages.unknownError);
      if (error.statusCode === 401) {
        displaySubtitle = formatMessage(messages.errorBadToken);
      }
      props.addError({
        id: registerErrorId,
        displayTitle,
        displaySubtitle,
        temporary: false,
        code: error.statusCode
      });
    }

    else if (sparkInstance && sparkState.get('authenticated') && sparkState.get('registered')) {
      RecentsWidget.getFeatureFlags(props);

      // Setup Web Sockets
      if (!mercury.getIn(['status', 'hasConnected'])
        && !mercury.getIn(['status', 'connecting'])
        && !mercury.getIn(['status', 'connected'])
        && sparkInstance.internal.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      if (mercury.getIn(['status', 'connected'])) {
        // Grab spaces
        if (!widgetStatus.isFetchingRecentSpaces
          && !widgetStatus.hasFetchedRecentSpaces) {
          props.updateWidgetStatus({isFetchingRecentSpaces: true});
          props.fetchSpaces({
            limit: 15,
            deferDecrypt: true
          }, sparkInstance)
            .then(() => {
              props.updateWidgetStatus({hasFetchedRecentSpaces: true});
            });
          props.fetchSpaces({
            limit: 1000
          }, sparkInstance)
            .then(() => {
              props.updateWidgetStatus({isFetchingRecentSpaces: false});
            });
        }

        // Grab teams
        if (sparkInstance.internal.team
          && !widgetStatus.isFetchingTeams
          && !widgetStatus.hasFetchedTeams) {
          props.updateWidgetStatus({isFetchingTeams: true});
          props.fetchTeams(sparkInstance)
            .then(() => {
              props.updateWidgetStatus({
                isFetchingTeams: false,
                hasFetchedTeams: true
              });
            });
        }
      }

      // Listen for incoming calls
      const hasCheckedWebRTCSupport = media.getIn(['webRTC', 'hasCheckedSupport']);
      const isWebRTCSupported = media.getIn(['webRTC', 'isSupported']);

      if (!hasCheckedWebRTCSupport) {
        props.checkWebRTCSupport(sparkInstance);
      }
      if (isWebRTCSupported && !media.getIn(['status', 'isListening'])) {
        props.listenForIncomingCalls(sparkInstance);
      }
    }
    if (widgetStatus.hasFetchedRecentSpaces) {
      metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
    }
  }

  @autobind
  static getFeatureFlags(props) {
    const {
      widgetStatus
    } = props;
    if (widgetStatus.hasFetchedFeatureFlags || widgetStatus.isFetchingFeatureFlags) {
      return;
    }
    props.getFeature('developer', FEATURE_GROUP_CALLING, props.sparkInstance);
    props.updateWidgetStatus({hasFetchedFeatureFlags: true, isFetchingFeatureFlags: false});
  }

  static checkForMercuryErrors(props) {
    const {
      errors,
      intl,
      mercury
    } = props;
    // Add Mercury disconnect error
    const mercuryError = 'mercury.disconnect';
    const isMercuryConnected = mercury.getIn(['status', 'connected']);
    const isMercuryDisconnected = !isMercuryConnected && mercury.getIn(['status', 'hasConnected']);
    const hasError = errors.get('hasError');
    const hasMercuryError = errors.get('errors').has(mercuryError);
    const hasNoMercuryError = !hasError || !hasMercuryError;
    if (isMercuryDisconnected && hasNoMercuryError) {
      // Create UI Error
      const {formatMessage} = intl;
      props.addError({
        id: mercuryError,
        displayTitle: formatMessage(messages.errorConnection),
        displaySubtitle: formatMessage(messages.reconnecting),
        temporary: true
      });
    }
    if (isMercuryConnected && hasMercuryError) {
      props.removeError(mercuryError);
    }
  }

  componentWillReceiveProps(nextProps) {
    RecentsWidget.checkForMercuryErrors(nextProps);
    RecentsWidget.setup(nextProps);
    this.addListeners(nextProps);
    this.fetchAllAvatars(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.spacesList !== this.props.spacesList
      || nextProps.errors !== this.props.errors
      || nextProps.widgetRecents !== this.props.widgetRecents
      || nextProps.incomingCall !== this.props.incomingCall;
  }

  @autobind
  getSpaceFromCall(call) {
    return this.props.spacesList.get(call.instance.locus.conversationUrl.split('/').pop());
  }

  @autobind
  fetchAllAvatars(nextProps) {
    const {
      currentUser,
      spaces,
      spacesList,
      sparkInstance,
      widgetStatus
    } = nextProps;

    if (currentUser
      && widgetStatus.hasFetchedRecentSpaces
      && this.props.spacesList
    ) {
      spacesList.forEach((s) => {
        if (!s.isDecrypting) {
          if (
            s.type === 'direct'
            && s.toPersonId
          ) {
            nextProps.fetchAvatar({userId: s.toPersonId}, sparkInstance);
          }
          else if (
            s.type === 'group' &&
            spaces.has(s.id)
          ) {
            nextProps.fetchAvatar({space: spaces.get(s.id)}, sparkInstance);
          }
        }
      });
    }
  }

  @autobind
  addListeners(nextProps) {
    const {
      currentUser,
      sparkInstance,
      widgetStatus,
      incomingCall
    } = nextProps;

    if (currentUser
      && widgetStatus.hasFetchedRecentSpaces
      && !widgetStatus.isListeningForNewActivity
    ) {
      this.listenForNewActivity(sparkInstance, nextProps);
    }
    if (incomingCall && !this.props.incomingCall) {
      const space = this.getSpaceFromCall(incomingCall);
      this.handleEvent(eventNames.CALLS_CREATED, constructCallEventData(incomingCall.instance, space));
    }
  }

  @autobind
  handleShowMoreSpaces() {
    const {
      widgetRecents
    } = this.props;
    this.props.updateVisibilityCount(widgetRecents.visibilityCount + 15);
  }

  @autobind
  handleNewActivity(activity) {
    const {
      props,
      processActivity
    } = this;
    const {
      sparkInstance,
      spacesList
    } = props;

    let spaceId = activity.target && activity.target.id;

    // On delete, refetch space to get previous activity
    if (spaceId && ['delete', 'tombstone'].includes(activity.verb)) {
      props.fetchSpace(sparkInstance, spaceId);
    }

    // Handle spaceId if this is a completely new space or hiding a space
    if (!spaceId && ['create', 'hide'].includes(activity.verb)) {
      spaceId = activity.object.id;
    }

    const space = spacesList.get(spaceId);

    if (space) {
      processActivity(activity, space);
    }
    else {
      // go retrieve the space if it doesn't exist
      props.fetchSpace(sparkInstance, spaceId)
        .then((newSpace) => {
          if (newSpace) {
            processActivity(activity, newSpace);
          }
        });
    }
  }

  @autobind
  processActivity(activity, space) {
    const {props, handleEvent} = this;
    const {
      currentUser
    } = props;
    props.storeActivities([activity]);
    const isSelf = activity.actor.id === currentUser.id;
    switch (activity.verb) {
      case 'share':
      case 'post': {
        const currentUserEmail = currentUser.email;
        const otherUser = space.participants
          .find((p) => p.emailAddress !== currentUserEmail);

        // Update space with newest post activity
        props.updateSpaceWithActivity(activity, isSelf, true);

        // Do not emit unread if current user created the message
        if (!isSelf) {
          handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
        }
        // Emit message:created event
        handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser));
        break;
      }
      case 'lock':
      case 'unlock': {
        props.updateSpaceWithActivity(activity, isSelf);
        break;
      }
      case 'acknowledge': {
        if (isSelf) {
        // update space with last acknowledgment if it's this user
          props.updateSpaceRead(activity.target.id, activity.published);
          handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
        }
        break;
      }
      case 'create': {
        const constructedActivity = Object.assign({}, activity, {
          target: activity.object,
          object: {
            id: currentUser.id,
            emailAddress: currentUser.email
          }
        });
        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(constructedActivity));
        break;
      }
      case 'add': {
        handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity));
        break;
      }
      case 'leave': {
        props.removeSpace(space.id);
        handleEvent(eventNames.MEMBERSHIPS_DELETED, constructMembershipEventData(activity));
        break;
      }
      case 'hide': {
        props.removeSpace(space.id);
        break;
      }
      default:
    }
  }

  /**
   * Setup listeners for new activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForNewActivity(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForNewActivity: true});
    return sparkInstance.internal.mercury.on('event:conversation.activity',
      (event) => this.handleNewActivity(event.data.activity));
  }

  /**
   * Setup listeners for call activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForCall(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForCalls: true});
    return sparkInstance.phone.on('call:incoming', (call) => this.handleCall(call));
  }


  @autobind
  handleCall(call) {
    const {
      props,
      handleEvent
    } = this;
    const {
      hasGroupCalling,
      spacesList
    } = props;

    const space = spacesList.get(call.locus.conversationUrl.split('/').pop());
    // Only provide event if the call is direct
    if (hasGroupCalling || space.type === 'direct') {
      call.acknowledge()
        .then(() => {
          const removeIncoming = () => call.hangup().then(props.deleteIncomingCall);

          // If call signals inactive we fire hangup and clean up
          call.once('inactive', removeIncoming);

          // If call signals connected we clean up
          const checkForConnected = () => {
            if (call.me.state === 'connected') {
              call.off('membership:change', checkForConnected);
              call.off('inactive', removeIncoming);
              props.deleteIncomingCall();
            }
          };
          call.on('membership:change', checkForConnected);

          props.storeIncomingCall(call);
          handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
        });
    }
  }

  @autobind
  handleAnswer() {
    const space = this.getSpaceFromCall(this.props.incomingCall);
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL_ANSWER,
      ...constructRoomsEventData(space)
    });
    this.props.dismissIncomingCall(this.props.incomingCall.instance.locus.url);
  }

  @autobind
  handleDecline() {
    const {
      props,
      getSpaceFromCall,
      handleEvent
    } = this;
    const space = getSpaceFromCall(props.incomingCall);

    props.declineIncomingCall(props.incomingCall.instance);
    handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL_REJECT,
      ...constructRoomsEventData(space)
    });
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  @autobind
  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }


  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undefined}
   */
  @autobind
  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    const logData = Object.assign({}, data);
    // Omit call objet from logger to prevent call range error
    if (data.call) {
      logData.call = '--- OMITTED ---';
    }
    sparkInstance.logger.info(`event handler - ${name} - ${data.action}`, logData);
    if (typeof onEvent === 'function') {
      this.props.onEvent(name, data);
    }
  }


  render() {
    const {props} = this;
    const {
      errors,
      hasGroupCalling,
      incomingCall,
      media,
      spacesList,
      spaces,
      currentUser,
      widgetRecents,
      widgetStatus
    } = props;
    const {formatMessage} = props.intl;
    const isFetchingSpaces = widgetStatus.isFetchingRecentSpaces;
    const hasFetchedSpaces = widgetStatus.hasFetchedRecentSpaces;

    const hasMoreSpaces = spacesList.count() < spaces.count();
    const isShowingMoreSpaces = widgetRecents.visibilityCount > spaces.count();
    const showLoader = isFetchingSpaces && isShowingMoreSpaces;
    const showMoreButton = (isFetchingSpaces || hasMoreSpaces) && !isShowingMoreSpaces;

    let displaySubtitle, displayTitle, temporary, widgetError;
    if (errors.get('hasError')) {
      widgetError = errors.get('errors').first();
      ({
        displayTitle,
        displaySubtitle,
        temporary
      } = widgetError);
    }

    const isWebRTCSupported = media.getIn(['webRTC', 'isSupported']);

    if (spacesList && hasFetchedSpaces) {
      if (incomingCall && isWebRTCSupported) {
        const space = this.getSpaceFromCall(incomingCall);
        return (
          <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
            <IncomingCall
              answerButtonLabel={formatMessage(messages.answerButtonLabel)}
              avatarImage={space.avatarUrl}
              declineButtonLabel={formatMessage(messages.declineButtonLabel)}
              displayName={space.name}
              incomingCallMessage={formatMessage(messages.incomingCallMessage)}
              onAnswerClick={this.handleAnswer}
              onDeclineClick={this.handleDecline}
            />
          </div>
        );
      }

      const handleCallClick = isWebRTCSupported ? this.handleSpaceCallClick : undefined;
      return (
        <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
          {
            errors.get('hasError') &&
            <div className={classNames('ciscospark-error-wrapper', styles.errorWrapper)}>
              <ErrorDisplay
                secondaryTitle={displaySubtitle}
                title={displayTitle}
                transparent={temporary}
              />
            </div>
          }
          <div className={classNames('ciscospark-spaces-list-wrapper', styles.spacesListWrapper)}>
            <SpacesList
              currentUser={currentUser}
              formatMessage={formatMessage}
              hasGroupCalling={hasGroupCalling}
              onCallClick={handleCallClick}
              onClick={this.handleSpaceClick}
              spaces={spacesList}
            />
            {
              showMoreButton &&
              <div className={styles.loadMoreContainer}>
                <button className={styles.loadMoreButton} onClick={this.handleShowMoreSpaces}>
                  {formatMessage(messages.viewOlderSpacesButtonLabel)}
                </button>
              </div>
            }
            {
              showLoader &&
              <div className={styles.spinner}>
                <Spinner bright />
              </div>
            }
          </div>
        </div>
      );
    }
    if (errors.get('hasError')) {
      return (
        <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
          <ErrorDisplay
            secondaryTitle={displaySubtitle}
            title={displayTitle}
            transparent={temporary}
          />
        </div>
      );
    }

    return (
      <div className={classNames('ciscospark-recents-widget', styles.recentsWidget)}>
        <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />
      </div>
    );
  }
}


RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};

export default connect(
  getRecentsWidgetProps,
  (dispatch) => bindActionCreators({
    acknowledgeSpace,
    addError,
    checkWebRTCSupport,
    connectToMercury,
    declineIncomingCall,
    dismissIncomingCall,
    fetchAvatar,
    fetchSpace,
    fetchSpaces,
    fetchTeams,
    getFeature,
    hideSpace,
    listenForIncomingCalls,
    removeError,
    removeSpace,
    updateSpaceRead,
    updateSpaceWithActivity,
    storeActivities,
    updateVisibilityCount,
    updateWidgetStatus
  }, dispatch)
)(RecentsWidget);
