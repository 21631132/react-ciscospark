export const UPDATE_MEDIA_STATE = `media/UPDATE_MEDIA_STATE`;
export function updateMediaState(mediaState) {
  return {
    type: UPDATE_MEDIA_STATE,
    payload: {
      mediaState
    }
  };
}

export const UPDATE_CALL_STATE = `media/UPDATE_CALL_STATE`;
export function updateCallState(callState) {
  return {
    type: UPDATE_CALL_STATE,
    payload: {
      callState
    }
  };
}

export const UPDATE_STATUS = `media/UPDATE_STATUS`;
export function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

export const STORE_CALL = `media/STORE_CALL`;
export function storeCall(call) {
  return {
    type: STORE_CALL,
    payload: {
      call
    }
  };
}

export const CALL_CONNECTED = `media/CALL_CONNECTED`;
export function callConnected(call) {
  return {
    type: CALL_CONNECTED,
    payload: {
      call
    }
  };
}

export const CALL_DISCONNECTED = `media/CALL_DISCONNECTED`;
export function callDisconnected() {
  return {
    type: CALL_DISCONNECTED
  };
}

export const CALL_INCOMING = `media/CALL_INCOMING`;
export function callIncoming(call) {
  return {
    type: CALL_INCOMING,
    payload: {
      call
    }
  };
}

export const DISCONNECT_CALL_INCOMING = `media/DISCONNECT_CALL_INCOMING`;
export function disconnectCallIncoming(call) {
  return {
    type: DISCONNECT_CALL_INCOMING,
    payload: {
      call
    }
  };
}

export const UPDATE_LOCAL_MEDIA = `media/UPDATE_LOCAL_MEDIA`;
export function updateLocalMedia(mediaState) {
  return {
    type: UPDATE_LOCAL_MEDIA,
    payload: {
      mediaState
    }
  };
}

export const UPDATE_REMOTE_MEDIA = `media/UPDATE_REMOTE_MEDIA`;
export function updateRemoteMedia(mediaState) {
  return {
    type: UPDATE_REMOTE_MEDIA,
    payload: {
      mediaState
    }
  };
}

export function bindCallActions(dispatch, call) {
  const callState = {
    receivingAudio: call.receivingAudio,
    receivingVideo: call.receivingVideo,
    sendingAudio: call.sendingAudio,
    sendingVideo: call.sendingVideo,
    localAudioDirection: call.localAudioDirection,
    localVideoDirection: call.localVideoDirection,
    remoteMediaStreamUrl: call.remoteMediaStreamUrl,
    localMediaStreamUrl: call.localMediaStreamUrl
  };
  call.once(`connected`, () => dispatch(callConnected(call)));
  call.once(`disconnected`, () => dispatch(callDisconnected(call)));
  call.on(`change:status`, () => dispatch(updateCallState(callState)));
  // call.on(`change:sendingAudio`, () => dispatch(updateCallState(callState)));
  // call.on(`change:receivingAudio`, () => dispatch(updateCallState(callState)));
  // call.on(`change:sendingVideo`, () => dispatch(updateCallState(callState)));
  // call.on(`change:receivingVideo`, () => dispatch(updateCallState(callState)));
}

export function bindMediaActions(dispatch, call) {
  call.on(`remoteMediaStream:change`, () => dispatch(updateRemoteMedia({
    receivingAudio: call.receivingAudio,
    receivingVideo: call.receivingVideo,
    sendingAudio: call.sendingAudio,
    sendingVideo: call.sendingVideo,
    url: call.remoteMediaStreamUrl
  })));
  call.on(`localMediaStream:change`, () => dispatch(updateLocalMedia({
    localAudioDirection: call.localAudioDirection,
    localVideoDirection: call.localVideoDirection,
    url: call.localMediaStreamUrl
  })));
}

export function callUser({userId, constraints = {}}, spark) {
  return (dispatch) => {
    dispatch(updateStatus({isDialing: true}));
    spark.phone.createLocalMediaStream(constraints)
      .then((localMediaStream) => {
        const call = spark.phone.dial(
          userId,
          Object.assign({constraints}, {localMediaStream})
        );
        dispatch(storeCall(call));
        bindCallActions(dispatch, call);
        bindMediaActions(dispatch, call);
      });
  };
}

export function hangupCall(call) {
  return (dispatch) => {
    call.hangup().then(() => {
      dispatch(callDisconnected());
    });
  };
}

/**
 * Listens for incoming calls from a particular person
 *
 * @export
 * @param {object} spark
 * @param {string} personId
 * @returns {Promise}
 */
export function listenForIncomingCalls(spark, personId) {
  return (dispatch) => {
    dispatch(updateStatus({isListening: true}));
    spark.phone.on(`call:incoming`, (incomingCall) => {
      if (incomingCall.from.person.id !== personId) {
        return;
      }
      const dispatchDisconnect = () => dispatch(disconnectCallIncoming(incomingCall));
      dispatch(updateStatus({isIncoming: true}));
      incomingCall.acknowledge()
        .then(() => dispatch(callIncoming(incomingCall)));
      incomingCall.once(`disconnected`, dispatchDisconnect);
      incomingCall.once(`connected`, () => incomingCall.off(`disconnected`, dispatchDisconnect));
    });
  };
}

export function declineIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.reject()
      .then(() => {
        dispatch(disconnectCallIncoming(incomingCall));
      });
  };
}
