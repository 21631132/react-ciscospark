import {compose, lifecycle} from 'recompose';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {resetErrors} from '@ciscospark/redux-module-errors';
import {constructHydraId, hydraTypes, isUuid} from '@ciscospark/react-component-utils';

import {
  getSpaceDetails,
  reloadWidget,
  storeDestination,
  storeSpaceDetails,
  updateWidgetStatus
} from '../actions';

import {getSpaceWidgetProps} from '../selector';

import {destinationTypes} from '../';

/**
 * Normalizes destination id to either email or hydra id
 *
 * @param {string} destination.id
 * @param {string} destination.type
 * @returns {string}
 */
function normalizeDestinationId({id, type}) {
  if (type === destinationTypes.USERID) {
    let destinationId = id;
    if (isUuid(id)) {
      destinationId = constructHydraId(hydraTypes.PEOPLE, id);
    }
    return destinationId;
  }
  if (type === destinationTypes.SPACEID) {
    let destinationId = id;
    if (isUuid(id)) {
      destinationId = constructHydraId(hydraTypes.ROOM, id);
    }
    return destinationId;
  }
  return id;
}

/**
 * Converts props into a destination object
 *
 * @param {*} props
 * @returns {Object} destination
 * @returns {string} destination.id
 * @returns {string} destination.type
 * @returns {string} destination.warning
 */
function getDestinationFromProps(props) {
  const {
    destinationId,
    destinationType,
    spaceId,
    sparkInstance,
    toPersonEmail,
    toPersonId
  } = props;

  if (destinationType && destinationId) {
    return {type: destinationType, id: normalizeDestinationId({type: destinationType, id: destinationId})};
  }
  if (spaceId) {
    sparkInstance.logger.warn();
    return {
      type: destinationTypes.SPACEID,
      id: normalizeDestinationId({type: destinationTypes.SPACEID, id: spaceId}),
      warning: 'The Space ID property is deprecated. Please use Destination ID and Type instead.'
    };
  }
  if (toPersonEmail) {
    return {
      type: destinationTypes.EMAIL,
      id: toPersonEmail,
      warning: 'The To Person Email property is deprecated. Please use Destination ID and Type instead.'
    };
  }
  if (toPersonId) {
    sparkInstance.logger.warn('The To Person ID property is deprecated. Please use Destination ID and Type instead.');
    return {
      type: destinationTypes.USERID,
      id: normalizeDestinationId({type: destinationTypes.USERID, id: toPersonId}),
      warning: 'The To Person ID property is deprecated. Please use Destination ID and Type instead.'
    };
  }
  return null;
}

function setup(props, prevProps) {
  const {
    conversation,
    destination,
    errors,
    sparkInstance,
    sparkState,
    metrics,
    spaceDetails,
    widgetStatus
  } = props;

  if (sparkInstance
    && sparkState.get('authenticated')
    && sparkState.get('registered')
    && !sparkState.get('hasError')
  ) {
    // Check if we need to reload space
    if (widgetStatus.shouldReloadWidget && prevProps && !prevProps.widgetStatus.shouldReloadWidget) {
      props.reloadWidget();
      props.resetErrors();
    }

    // Check for destination Change
    if (destination && prevProps.destination) {
      const calculatedDestination = getDestinationFromProps(props);
      const calculatedPreviousDestination = getDestinationFromProps(prevProps);
      if (
        calculatedPreviousDestination.id !== calculatedDestination.id
        || calculatedPreviousDestination.type !== calculatedDestination.type
      ) {
        sparkInstance.logger.info('Destination has changed, widget reloading...');
        props.updateWidgetStatus({
          shouldReloadWidget: true
        });
      }
    }

    // Get space details for given destination
    if (!widgetStatus.isFetchingSpaceDetails && !errors.get('hasError') && !spaceDetails) {
      // If the selector isn't returning a destination object and we have props for them, store
      if (destination) {
        // Use destination object from store to fetch space details
        // Instead of using props because of legacy prop support
        props.getSpaceDetails({
          sparkInstance,
          destinationId: destination.id,
          destinationType: destination.type,
          intl: props.intl
        });
      }
      else {
        const calculatedDestination = getDestinationFromProps(props);
        if (calculatedDestination.warning) {
          sparkInstance.logger.warn(calculatedDestination.warning);
        }
        props.storeDestination(calculatedDestination);
      }
    }

    if (conversation.get('id')) {
      metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
      props.fetchAvatar({space: conversation.toJS()}, sparkInstance);
    }
  }
}

export default compose(
  connect(
    getSpaceWidgetProps,
    (dispatch) => bindActionCreators({
      getSpaceDetails,
      reloadWidget,
      resetErrors,
      storeDestination,
      storeSpaceDetails,
      updateWidgetStatus,
      fetchAvatar
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      setup(this.props);
    },
    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    },
    componentWillReceiveProps(nextProps) {
      setup(nextProps, this.props);
    }
  })
);
