import {compose, lifecycle} from 'recompose';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import {fetchAvatar} from '@ciscospark/redux-module-avatar';

import {
  getSpaceDetails,
  storeSpaceDetails
} from '../actions';

import {getSpaceWidgetProps} from '../selector';

function setup(props) {
  const {
    conversation,
    errors,
    spaceId,
    sparkInstance,
    sparkState,
    toPersonEmail,
    toPersonId,
    metrics,
    spaceDetails,
    widgetStatus
  } = props;

  if (sparkInstance
    && sparkState.get('authenticated')
    && sparkState.get('registered')
    && !sparkState.get('hasError')) {
    if (!widgetStatus.isFetchingSpaceDetails && !errors.get('hasError') && !spaceDetails) {
      if (spaceId) {
        props.getSpaceDetails(sparkInstance, spaceId, props.intl);
      }
      // Hack until we find a way to get a one-on-one space's details before loading conversation
      else if (toPersonEmail || toPersonId) {
        props.storeSpaceDetails({
          type: 'direct'
        });
      }
    }

    if (conversation.get('id')) {
      metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
      props.fetchAvatar({space: conversation.toJS()}, sparkInstance);
    }
  }
}

export default compose(
  connect(
    getSpaceWidgetProps,
    (dispatch) => bindActionCreators({
      getSpaceDetails,
      storeSpaceDetails,
      fetchAvatar
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      setup(this.props);
    },
    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    },
    componentWillReceiveProps(nextProps) {
      setup(nextProps);
    }
  })
);
