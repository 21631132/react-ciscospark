import {connect} from 'react-redux';
import {compose, lifecycle} from 'recompose';
import {bindActionCreators} from 'redux';
import {addError, removeError} from '@ciscospark/redux-module-errors';

import messages from '../messages';


function checkForMercuryErrors(props) {
  const {
    errors,
    intl,
    mercury
  } = props;
  // Add Mercury disconnect error
  const mercuryError = 'mercury.disconnect';
  const isMercuryConnected = mercury.getIn(['status', 'connected']);
  const isMercuryDisconnected = !isMercuryConnected && mercury.getIn(['status', 'hasConnected']);
  const hasError = errors.get('hasError');
  const hasMercuryError = errors.get('errors').has(mercuryError);
  const hasNoMercuryError = !hasError || !hasMercuryError;
  if (isMercuryDisconnected && hasNoMercuryError) {
    // Create UI Error
    const {formatMessage} = intl;
    props.addError({
      id: mercuryError,
      displayTitle: formatMessage(messages.errorConnection),
      displaySubtitle: formatMessage(messages.reconnecting),
      temporary: true
    });
  }
  if (isMercuryConnected && hasMercuryError) {
    props.removeError(mercuryError);
  }
}

function checkForErrors(props) {
  const {
    errors,
    spaceId,
    sparkState,
    spark,
    toPersonEmail,
    toPersonId,
    users,
    widgetSpace
  } = props;
  const {formatMessage} = props.intl;
  const registerErrorId = 'spark.register';
  const toPerson = widgetSpace.get('toPerson');
  if (sparkState.get('registerError') && (!errors.get('hasError') || !errors.get('errors').has(registerErrorId))) {
    const error = spark.get('error');
    let displaySubtitle = formatMessage(messages.unknownError);
    if (error.statusCode === 401) {
      displaySubtitle = formatMessage(messages.errorBadToken);
    }
    props.addError({
      id: registerErrorId,
      displayTitle: formatMessage(messages.unableToLoad),
      displaySubtitle,
      temporary: false,
      code: error.statusCode
    });
  }

  const missingDestinationErrorId = 'space.error.missingDestination';
  if (
    !toPersonEmail && !toPersonId && !spaceId &&
    (!errors.get('hasError') || !errors.get('errors').has(missingDestinationErrorId))
  ) {
    // No destination found
    props.addError({
      id: missingDestinationErrorId,
      displayTitle: formatMessage(messages.unableToLoad),
      displaySubtitle: formatMessage(messages.unknownDestination),
      temporary: false
    });
  }

  const toSelfErrorId = 'space.error.toSelf';
  const currentUser = users.getIn(['byId', users.get('currentUserId')]);
  if (toPerson && currentUser && (!errors.get('hasError') || !errors.get('errors').has(toSelfErrorId))) {
    // Check for to user being self
    if ([currentUser.id, currentUser.email].includes(toPerson)) {
      props.addError({
        id: toSelfErrorId,
        displayTitle: formatMessage(messages.unableToLoad),
        displaySubtitle: formatMessage(messages.errorToSelf),
        temporary: false
      });
    }
  }
}

export default compose(
  connect(
    (state) => state,
    (dispatch) => bindActionCreators({
      addError,
      removeError
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      checkForErrors(this.props);
      checkForMercuryErrors(this.props);
    },
    componentWillReceiveProps: (nextProps) => {
      checkForMercuryErrors(nextProps);
      checkForErrors(nextProps);
    }
  })
);
