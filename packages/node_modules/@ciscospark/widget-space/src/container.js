import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';
import {compose} from 'recompose';

import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import MessageWidget from '@ciscospark/widget-message';
import MeetWidget from '@ciscospark/widget-meet';
import RosterWidget from '@ciscospark/widget-roster';
import TitleBar from '@ciscospark/react-component-title-bar';
import Button from '@ciscospark/react-component-button';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Timer from '@ciscospark/react-component-timer';
import ErrorDisplay from '@ciscospark/react-component-error-display';

import {
  getFeature,
  FEATURE_GROUP_CALLING,
  FEATURE_ROSTER
} from '@ciscospark/redux-module-features';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {
  ICON_TYPE_CONTACT,
  ICON_TYPE_MESSAGE_OUTLINE,
  ICON_TYPE_VIDEO_OUTLINE,
  ICON_TYPE_WAFFLE
} from '@ciscospark/react-component-icon';

import ActivityMenu from './components/activity-menu';

import {
  getSpaceDetails,
  updateActivityType,
  updateSecondaryActivityType,
  storeActivityTypes,
  storeToPerson,
  storeSpaceDetails,
  toggleActivityMenuVisible,
  updateWidgetStatus
} from './actions';
import messages from './messages';
import {getSpaceWidgetProps} from './selector';
import styles from './styles.css';
import {eventNames} from './events';
import enhancers from './enhancers';


const ACTIVITY_TYPE_PRIMARY = 'ACTIVITY_TYPE_PRIMARY';
const ACTIVITY_TYPE_SECONDARY = 'ACTIVITY_TYPE_SECONDARY';
const DEFAULT_ACTIVITY = 'message';

const injectedPropTypes = {
  activityTypes: PropTypes.array.isRequired,
  call: PropTypes.object,
  conversation: PropTypes.object.isRequired,
  errors: PropTypes.object.isRequired,
  media: PropTypes.object.isRequired,
  mercury: PropTypes.object.isRequired,
  sparkInstance: PropTypes.object,
  user: PropTypes.object.isRequired,
  widgetSpace: PropTypes.object.isRequired,
  connectToMercury: PropTypes.func.isRequired,
  fetchAvatar: PropTypes.func.isRequired,
  getFeature: PropTypes.func.isRequired,
  getSpaceDetails: PropTypes.func.isRequired,
  storeActivityTypes: PropTypes.func.isRequired,
  storeSpaceDetails: PropTypes.func.isRequired,
  toggleActivityMenuVisible: PropTypes.func.isRequired,
  updateActivityType: PropTypes.func.isRequired,
  updateSecondaryActivityType: PropTypes.func.isRequired,
  updateWidgetStatus: PropTypes.func.isRequired
};

export const ownPropTypes = {
  customActivityTypes: PropTypes.object,
  initialActivity: PropTypes.string,
  muteNotifications: PropTypes.bool,
  spaceId: PropTypes.string,
  startCall: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.bool
  ]),
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string,
  ...injectedPropTypes
};

const defaultProps = {
  customActivityTypes: undefined,
  initialActivity: DEFAULT_ACTIVITY,
  muteNotifications: false,
  spaceId: '',
  startCall: false,
  toPersonEmail: '',
  toPersonId: ''
};

export class SpaceWidget extends Component {
  @autobind
  static getFeatureFlags(props) {
    const {
      widgetSpace,
      widgetStatus
    } = props;
    if (widgetStatus.get('hasFetchedFeatureFlags') || widgetStatus.get('isFetchingFeatureFlags')) {
      return;
    }
    props.updateWidgetStatus({isFetchingFeatureFlags: true});
    widgetSpace.get('activityTypes').toJS().forEach((activityType) => {
      if (!activityType.feature) {
        return;
      }
      props.getFeature(activityType.feature.type, activityType.feature.key, props.sparkInstance);
    });
    props.updateWidgetStatus({hasFetchedFeatureFlags: true, isFetchingFeatureFlags: false});
  }


  @autobind
  static setup(props) {
    const {
      conversation,
      errors,
      spaceId,
      sparkInstance,
      sparkState,
      toPersonEmail,
      toPersonId,
      mercury,
      metrics,
      user,
      spaceDetails,
      widgetStatus
    } = props;

    if (sparkInstance
      && sparkState.get('authenticated')
      && sparkState.get('registered')
      && !sparkState.get('hasError')) {
      // Get current user details
      if (!user.getIn(['status', 'isFetchingCurrentUser']) && !user.get('currentUser')) {
        props.fetchCurrentUser(sparkInstance);
      }
      if (!widgetStatus.get('isFetchingSpaceDetails') && !errors.get('hasError') && !spaceDetails) {
        if (spaceId) {
          props.getSpaceDetails(sparkInstance, spaceId, props.intl);
        }
        // Hack until we find a way to get a one-on-one space's details before loading conversation
        else if (toPersonEmail || toPersonId) {
          props.storeSpaceDetails({
            type: 'direct'
          });
        }
      }

      SpaceWidget.getFeatureFlags(props);

      // Setup Web Sockets
      if (!mercury.getIn(['status', 'hasConnected'])
        && !mercury.getIn(['status', 'isConnecting'])
        && !mercury.getIn(['status', 'isConnected'])
        && sparkInstance.internal.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      if (conversation.get('id')) {
        metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
        props.fetchAvatar({space: conversation.toJS()}, sparkInstance);
      }
    }
  }

  constructor(props) {
    super(props);
    // Store activity types used in widget
    const DEFAULT_ACTIVITY_TYPES = [
      {
        displayName: 'Message',
        name: 'message',
        buttonClassName: styles.messageButton,
        iconClassName: ICON_TYPE_MESSAGE_OUTLINE,
        component: MessageWidget,
        spaceTypes: ['group', 'direct'],
        type: ACTIVITY_TYPE_PRIMARY
      },
      {
        displayName: 'Call',
        name: 'meet',
        buttonClassName: styles.meetButton,
        iconClassName: ICON_TYPE_VIDEO_OUTLINE,
        component: MeetWidget,
        spaceTypes: ['direct', 'group'],
        type: ACTIVITY_TYPE_PRIMARY,
        feature: {
          type: 'developer',
          key: FEATURE_GROUP_CALLING
        }
      },
      {
        displayName: 'Call',
        name: 'meet',
        buttonClassName: styles.meetButton,
        iconClassName: ICON_TYPE_VIDEO_OUTLINE,
        component: MeetWidget,
        spaceTypes: ['direct'],
        type: ACTIVITY_TYPE_PRIMARY,
        feature: {
          type: 'developer',
          key: FEATURE_GROUP_CALLING,
          // Hide this option if feature flag is set
          hide: true
        }
      },
      {
        displayName: 'People',
        name: 'people',
        buttonClassName: styles.peopleButton,
        iconClassName: ICON_TYPE_CONTACT,
        component: RosterWidget,
        spaceTypes: ['direct', 'group'],
        type: ACTIVITY_TYPE_SECONDARY,
        props: {
          onClickClose: this.handleSecondaryDismiss,
          onClickMenu: this.handleMenuClick
        },
        feature: {
          type: 'developer',
          key: FEATURE_ROSTER
        }
      }
    ];

    let activityTypes = DEFAULT_ACTIVITY_TYPES;
    if (typeof props.customActivityTypes === 'object') {
      activityTypes = activityTypes.concat(props.customActivityTypes);
    }
    props.storeActivityTypes(activityTypes);

    if (props.toPersonEmail || props.toPersonId) {
      props.storeToPerson(props.toPersonEmail || props.toPersonId);
    }
  }

  componentWillMount() {
    SpaceWidget.setup(this.props);
  }

  componentWillReceiveProps(nextProps) {
    const {
      call,
      spaceDetails,
      activityTypes,
      initialActivity
    } = nextProps;
    SpaceWidget.setup(nextProps);
    const {props} = this;
    const prevCall = props.call;
    // Switch to Meet if ringing
    if (call && !prevCall) {
      nextProps.updateActivityType('meet');
    }

    // Reset back to message view after call ends
    if (prevCall && !call) {
      nextProps.updateActivityType('message');
    }

    // Set the initial activity once we get space details
    if (!props.spaceDetails && spaceDetails) {
      if (activityTypes.find((a) => a.name === initialActivity)) {
        props.updateActivityType(initialActivity);
      }
      else {
        props.updateActivityType(DEFAULT_ACTIVITY);
      }
    }
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.removeWidget();
  }

  @autobind
  handleActivityChange(activity) {
    if (activity.type === ACTIVITY_TYPE_PRIMARY) {
      this.props.updateActivityType(activity.name);
    }
    else {
      this.props.updateSecondaryActivityType(activity.name);
    }
  }

  @autobind
  handleSecondaryDismiss() {
    this.props.updateSecondaryActivityType(null);
  }

  @autobind
  handleMenuClick() {
    this.props.toggleActivityMenuVisible();
  }

  /**
   * Builds widget elements from activityTypes list
   *
   * @param {List} activityTypes Immutable List of activity types
   * @param {String} primaryActivityType Active activity type
   * @returns {Array} of Widget elements
   */
  @autobind
  constructActivityWidgets(activityTypes, primaryActivityType) {
    return activityTypes
      .filter((activityType) => activityType.type !== ACTIVITY_TYPE_SECONDARY)
      .map((a) => {
        // Only allow widget if it's available for this space type
        const Widget = a.component;
        const isVisible = primaryActivityType === a.name ? '' : styles.hidden;
        return (
          <div
            className={classNames(`ciscospark-${a.name}-wrapper`, styles.activityComponentWrapper, isVisible)}
            key={a.name}
          >
            <Widget
              {...this.props}
              eventNames={eventNames}
              injectProvider={false}
              toPerson={this.props.spaceDetails.get('toPerson')}
            />
          </div>
        );
      });
  }

  /**
   * Builds secondary widget elements
   *
   * @param {List} activityTypes
   * @param {String} secondaryActivityType
   * @returns {undefined}
   */
  @autobind
  constructSecondaryActivityWidget(activityTypes, secondaryActivityType) {
    if (!secondaryActivityType) {
      return null;
    }
    return activityTypes
      .filter((activityType) =>
        activityType.type === ACTIVITY_TYPE_SECONDARY && activityType.name === secondaryActivityType)
      .map((activityType) => {
        const Widget = activityType.component;
        return (
          <div
            className={classNames('ciscospark-secondary-widget', styles.secondaryWidget)}
            key={activityType.name}
          >
            <Widget
              {...this.props}
              {...activityType.props}
              eventNames={eventNames}
              injectProvider={false}
            />
          </div>
        );
      });
  }

  render() {
    const {props} = this;
    const {
      activityTypes,
      conversation,
      media,
      sparkInstance,
      spaceDetails,
      errors,
      widgetSpace,
      widgetStatus
    } = props;

    const {formatMessage} = props.intl;
    let errorElement;
    if (errors.get('hasError') || conversation.getIn(['status', 'error'])) {
      let widgetError = errors.get('errors').first();
      if (!widgetError) {
        widgetError = {
          displaySubtitle: conversation.getIn(['status', 'error', 'description']),
          temporary: false,
          title: formatMessage(messages.errorConversation)
        };
      }
      errorElement = (
        <div className={classNames('ciscospark-error-wrapper', styles.errorWrapper)}>
          <ErrorDisplay
            secondaryTitle={widgetError.displaySubtitle}
            title={widgetError.displayTitle}
            transparent={widgetError.temporary}
            {...widgetError}
          />
        </div>
      );
    }
    if (sparkInstance && spaceDetails) {
      // Construct widgets
      const primaryActivityType = widgetSpace.get('primaryActivityType');
      const secondaryActivityType = widgetSpace.get('secondaryActivityType');
      const widgets = this.constructActivityWidgets(activityTypes, primaryActivityType);
      const secondaryWidget = this.constructSecondaryActivityWidget(activityTypes, secondaryActivityType);
      const spaceTitle = spaceDetails.get('title') || 'Loading...';
      const avatarId = spaceDetails.get('avatarId');
      const callStartTime = media.get('callStartTime');
      return (
        <div className={classNames('ciscospark-space-widget', styles.spaceWidget)}>
          { errorElement }
          {
            widgetStatus.get('activityMenuVisible') &&
            <div className={classNames('ciscospark-activity-menu-wrapper', styles.activityMenuWrapper)}>
              <ActivityMenu
                activityTypes={activityTypes}
                onChange={this.handleActivityChange}
                onExit={this.handleMenuClick}
                showExitButton
              />
            </div>
          }
          {
            secondaryWidget
          }
          <div className={classNames('ciscospark-title-bar-wrapper', styles.titleBarWrapper)}>
            <TitleBar avatarId={avatarId} name={spaceTitle}>
              {
                callStartTime &&
                <div className={classNames('ciscospark-title-bar-call-timer', styles.callTimer)}>
                  <Timer startTime={callStartTime} />
                </div>
              }
              <div className={classNames('ciscospark-activity-menu-button-wrapper', styles.activityMenuButtonWrapper)}>
                <div className={classNames('ciscospark-activity-menu-button', styles.activityMenuButton)}>
                  <Button accessibilityLabel="Main Menu" iconType={ICON_TYPE_WAFFLE} onClick={this.handleMenuClick} />
                </div>
              </div>
            </TitleBar>
          </div>
          <div className={classNames('ciscospark-widget-body', styles.widgetBody)}>
            {widgets}
          </div>
        </div>
      );
    }
    if (errors.get('hasError')) {
      return errorElement;
    }

    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

SpaceWidget.propTypes = ownPropTypes;
SpaceWidget.defaultProps = defaultProps;

function mapStateToProps(state, props) {
  return getSpaceWidgetProps(state, props);
}

export default compose(
  connect(
    mapStateToProps,
    (dispatch) => bindActionCreators({
      connectToMercury,
      getFeature,
      getSpaceDetails,
      fetchAvatar,
      fetchCurrentUser,
      getSpaceWidgetProps,
      storeActivityTypes,
      storeSpaceDetails,
      storeToPerson,
      toggleActivityMenuVisible,
      updateActivityType,
      updateSecondaryActivityType,
      updateWidgetStatus
    }, dispatch)
  ),
  ...enhancers
)(SpaceWidget);
