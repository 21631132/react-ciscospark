import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import MessageWidget from '@ciscospark/widget-message';
import MeetWidget from '@ciscospark/widget-meet';
import TitleBar from '@ciscospark/react-component-title-bar';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {
  ICON_TYPE_MESSAGE_OUTLINE,
  ICON_TYPE_VIDEO_OUTLINE
} from '@ciscospark/react-component-icon';

import {
  getSpaceDetails,
  updateActivityType,
  storeActivityTypes,
  storeSpaceDetails
} from './actions';
import messages from './messages';
import {getSpaceWidgetProps} from './selector';
import styles from './styles.css';


const DEFAULT_ACTIVITY_TYPES = [
  {
    displayName: `Message`,
    name: `message`,
    buttonClassName: styles.messageButton,
    iconClassName: ICON_TYPE_MESSAGE_OUTLINE,
    component: MessageWidget,
    spaceTypes: [`group`, `direct`]
  },
  {
    displayName: `Call`,
    name: `call`,
    buttonClassName: styles.meetButton,
    iconClassName: ICON_TYPE_VIDEO_OUTLINE,
    component: MeetWidget,
    spaceTypes: [`direct`]
}
];


export class SpaceWidget extends Component {

  constructor(props) {
    super(props);
    // Store activity types used in widget
    let activityTypes = DEFAULT_ACTIVITY_TYPES;
    if (typeof props.customActivityTypes === `array`) {
      activityTypes = activityTypes.concat(props.customActivityTypes);
    }
    props.storeActivityTypes(activityTypes);
  }

  componentWillMount() {
    const props = this.props;
    const {
      activityTypes,
      initialActivity
    } = props;

    // Set initial activity type if valid choice
    if (activityTypes && activityTypes.has(initialActivity)) {
      props.updateActivityType(initialActivity);
    }
    this.setup(props);
  }

  componentWillReceiveProps(nextProps) {
    const {
      media
    } = nextProps;
    this.setup(nextProps);

    // Switch to Meet if ringing
    if (media.getIn([`status`, `isRinging`])) {
      nextProps.updateActivityType(`meet`);
    }

    // Reset back to message view after call ends
    if (!media.getIn([`status`, `isConnected`]) && media.getIn([`status`, `isConnected`])) {
      this.updateActivityType(`message`);
    }
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.sparkInstance.mercury.disconnect().then(() => this.props.removeWidget());
  }

  @autobind
  setup(props) {
    const {
      spaceId,
      sparkInstance,
      sparkState,
      mercury,
      user,
      spaceDetails,
      toPersonEmail,
      toPersonId,
      widgetStatus
    } = props;

    if (sparkInstance && sparkState.get(`authenticated`)) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }

      if (!widgetStatus.get(`fetchingSpaceDetails`) && !spaceDetails) {
        if (spaceId) {
          props.getSpaceDetails(sparkInstance, spaceId);
        }
        // Hack until we find a way to get a one-on-one space's details before loading conversation
        if (toPersonEmail || toPersonId) {
          props.storeSpaceDetails({
            type: `direct`
          });
        }
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`]) && sparkInstance.device.registered) {
        // props.connectToMercury(sparkInstance);
      }
    }
  }

  render() {
    const {
      activityTypes,
      sparkInstance,
      spaceDetails,
      widgetSpace
    } = this.props;

    const {formatMessage} = this.props.intl;

    if (sparkInstance && spaceDetails) {
      // Construct widgets
      const widgets = activityTypes.toJS().map((a) => {
        // Only allow widget if it's available for this space type
        if (a && a.spaceTypes.includes(spaceDetails.get(`type`))) {
          const Widget = a.component;
          const isVisible = widgetSpace.get(`activityType`) === a.name ? `` : styles.hidden;
          return (
            <div className={classNames(`ciscospark-${a.name}-wrapper`, styles.activityComponentWrapper, isVisible)} key={a.name}>
              <Widget {...this.props} injectProvider={false} />
            </div>
          );
        }
        return false;
      });

      return (
        <div className={classNames(`ciscospark-space-widget`, styles.spaceWidget)}>
          <div className={classNames(`ciscospark-widget-body`, styles.widgetBody)}>
            {widgets}
          </div>
        </div>
      );
    }

    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  activityTypes: PropTypes.object,
  conversation: PropTypes.object,
  media: PropTypes.object,
  mercury: PropTypes.object,
  sparkInstance: PropTypes.object,
  user: PropTypes.object,
  widgetSpace: PropTypes.object,
  getSpaceDetails: PropTypes.func,
  storeActivityTypes: PropTypes.func,
  storeSpaceDetails: PropTypes.func,
  updateActivityType: PropTypes.func
};

export const ownPropTypes = {
  customActivityTypes: PropTypes.object,
  intialActivity: PropTypes.string,
  muteNotifications: PropTypes.bool,
  spaceId: PropTypes.string,
  startCall: PropTypes.bool,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string
};

SpaceWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};

function mapStateToProps(state) {
  return getSpaceWidgetProps(state);
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    getSpaceDetails,
    fetchCurrentUser,
    getSpaceWidgetProps,
    storeActivityTypes,
    storeSpaceDetails,
    updateActivityType
  }, dispatch)
)(SpaceWidget);
