import React, {Component, PropTypes} from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import TitleBar from '@ciscospark/react-component-title-bar';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';

import {updateActivityType} from './actions';
import messages from './messages';
import styles from './styles.css';

export const ACTIVITY_TYPE = {
  MEET: `meet`,
  MESSAGE: `message`
};

export class SpaceWidget extends Component {

  componentWillMount() {
    const props = this.props;
    const {initialActivity} = props;

    if (Object.values(ACTIVITY_TYPE).includes(initialActivity)) {
      props.updateActivityType(initialActivity);
    }
    this.setup(props);
  }

  componentWillReceiveProps(nextProps) {
    const {
      media
    } = nextProps;
    this.setup(nextProps);

    // Switch to Meet if ringing
    if (media.getIn([`status`, `isRinging`])) {
      nextProps.updateActivityType(ACTIVITY_TYPE.MEET);
    }

    // Reset back to message view after call ends
    if (!media.getIn([`status`, `isConnected`]) && media.getIn([`status`, `isConnected`])) {
      this.updateActivityType(ACTIVITY_TYPE.MESSAGE);
    }
  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.sparkInstance.mercury.disconnect().then(() => this.props.removeWidget());
  }

  @autobind
  setup(props) {
    const {
      sparkInstance,
      sparkState,
      mercury,
      user
    } = props;

    if (sparkInstance && sparkState.authenticated) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`]) && sparkInstance.device.registered) {
        props.connectToMercury(sparkInstance);
      }
    }
  }

  render() {
    const {
      conversation,
      sparkInstance,
      widgetSpace
    } = this.props;

    const {formatMessage} = this.props.intl;

    if (sparkInstance && conversation) {
      return (
        <div className={classNames(`ciscospark-space-widget`)}>
          <div className={classNames(`ciscospark-titlebar-wrapper`, styles.titleBarWrapper)}>
            <TitleBar
              name={displayName}
              image={spaceImage}
            />
          </div>
          {
            widgetSpace.get(`activityMenuVisible`) &&
            <div className={classNames(`ciscospark-activity-menu-wrapper`, styles.activityMenuWrapper)}>
              <ActivityMenu
                onExit={this.handleMenuClick}
                onMeet={this.handleActivityMeet}
                onMessage={this.handleActivityMessage}
              />
            </div>
          }


          <div className={classNames(`ciscospark-activity-list-wrapper`, styles.activityListWrapper)}>
            <ActivityList />
          </div>
          <div className={classNames(`ciscospark-message-composer-wrapper`, styles.messageComposerWrapper)}>
            <MessageComposer />
          </div>
        </div>
      );
    }

    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  conversation: PropTypes.object,
  media: PropTypes.object,
  mercury: PropTypes.object,
  sparkInstance: PropTypes.object,
  user: PropTypes.object,
  widgetSpace: PropTypes.object,
  updateActivityType: PropTypes.func
};

export const ownPropTypes = {
  activityTypes: PropTypes.array,
  intialActivity: PropTypes.string,
  muteNotifications: PropTypes.bool,
  spaceId: PropTypes.string,
  startCall: PropTypes.bool,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string
};

SpaceWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};

SpaceWidget.defaultProps = {
  initialActivity: ACTIVITY_TYPE.MESSAGE,
  activityTypes: [
    {
      label: `Message`,
      buttonClassName: styles.messageButton,
      iconType: ICON_TYPE_MESSAGE_OUTLINE,
      component: MessageWidget
    },
    {
      label: `Call`,
      buttonClassName: styles.meetButton,
      iconType: ICON_TYPE_VIDEO_OUTLINE,
      component: MeetWidget
    }
  ]
};

function mapStateToProps(state) {
  const {
    spark,
    widgetSpace
  } = state;
  return {
    sparkInstance: spark.get(`spark`),
    sparkState: spark.get(`status`).toJS(),
    widgetSpace
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    fetchCurrentUser,
    updateActivityType
  }, dispatch)
)(SpaceWidget);
