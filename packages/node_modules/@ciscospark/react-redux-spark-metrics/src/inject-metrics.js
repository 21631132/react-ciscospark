import React, {Component, PropTypes} from 'react';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import autobind from 'autobind-decorator';

import {
  deleteMetric,
  storeStart,
  storeEnd,
  storeMetric,
  addToQueue,
  clearQueue
} from './actions';

const NS = `ciscospark-widget-`;

export default function injectSparkMetrics(WrappedComponent) {
  const defaultFields = {
    protocol: window.location.protocol,
    hostname: window.location.hostname,
    pathname: window.location.pathname,
    widgetVersion: process.env.REACT_CISCOSPARK_VERSION,
    iteration: 0
  };

  class InjectSparkMetrics extends Component {
    shouldComponentUpdate() {
      return true;
    }

    @autobind
    sendMetric(sparkInstance, metric) {
      const {
        resource
      } = metric;
      const formattedData = this.formatMetricData(metric);
      return sparkInstance.metrics
        .submitClientMetrics(`${NS}${resource}`, formattedData);
    }

    @autobind
    sendSavedMetric(sparkInstance, metricName) {
      const props = this.props;
      const {metricsStore} = props;
      const metric = metricsStore.getIn([`items`, metricName]);
      if (metric) {
        return this.sendMetric(sparkInstance, metric.toJS())
          .then(() => {
            return props.deleteMetric(metricName);
          });
      }
      return false;
    }

    @autobind
    sendQueue(sparkInstance) {
      const {sendMetric, props} = this;
      const {metricsStore} = props;

      props.updateMetricsStatus({isSendingQueue: true});
      return Promise.all(
        metricsStore.get(`queue`)
          .map((metric) => sendMetric(sparkInstance, metric))
        )
        .then(() => {
          props.clearQueue();
          return props.updateMetricsStatus({isSendingQueue: false});
        });
    }

    sendDuration() {

    }

    formatMetricData({data, action, event, fields, tags}) {
      return {
        type: [`operational`],
        tags: Object.assign({
          action,
          event
        }, tags),
        fields: Object.assign(defaultFields, {
          data
        }, fields)
      };
    }

    render() {
      const {
        props,
        sendQueue,
        sendSavedMetric,
        sendMetric
      } = this;
      const {
        storeMetric,
        addToQueue,
        clearQueue,
        storeStart,
        storeEnd
      } = props;

      const metrics = {
        sendQueue,
        sendSavedMetric,
        sendMetric,
        storeMetric,
        addToQueue,
        clearQueue,
        storeStart,
        storeEnd
      };

      if (props)

      return <WrappedComponent {...this.props} metrics={metrics} />;
    }
  }

  const injectedProps = {
    sparkInstance: PropTypes.object,
    metricsStore: PropTypes.object
  };

  InjectSparkMetrics.propTypes = {
    startTime: PropTypes.string,
    ...injectedProps
  };

  InjectSparkMetrics.displayName = `InjectSparkMetrics(${getDisplayName(WrappedComponent)})`;
  InjectSparkMetrics.WrappedComponent = WrappedComponent;

  return connect(
    (state) => ({
      metricsStore: state.metricsStore,
      sparkInstance: state.spark.get(`spark`)
    }),
    (dispatch) => bindActionCreators({
      deleteMetric,
      storeStart,
      storeEnd,
      storeMetric,
      addToQueue,
      clearQueue
    }, dispatch)
  )(InjectSparkMetrics);
}

function getDisplayName(C) {
  return C.displayName || C.name || `C`;
}
