import React, {Component, PropTypes} from 'react';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import autobind from 'autobind-decorator';

import {
  deleteMetric,
  storeMetric,
  addToQueue,
  clearQueue,
  updateMetricsStatus
} from './actions';

import {events} from './metrics-events';

const NS = `ciscospark-widget-`;


export default function injectSparkMetrics(WrappedComponent, startTime) {
  const defaultFields = {
    protocol: window.location.protocol,
    hostname: window.location.hostname,
    pathname: window.location.pathname,
    widgetVersion: process.env.REACT_CISCOSPARK_VERSION,
    iteration: 0
  };

  class InjectSparkMetrics extends Component {
    componentDidMount() {
      this.sendStartMetric({
        ...events.WIDGET_LOAD_START,
        data: this.props.startTime
      });
    }

    shouldComponentUpdate() {
      return true;
    }

    @autobind
    canSendMetric() {
      const {
        sparkInstance,
        sparkState
      } = this.props;
      return sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`);
    }


    @autobind
    hasQueuedMetrics() {
      const {
        metricsStore
      } = this.props;
      return metricsStore && metricsStore.get(`queue`).count();
    }


    @autobind
    sendMetric(metric) {
      const {props} = this;
      const {sparkInstance} = props;
      const {
        resource
      } = metric;
      const formattedData = this.formatMetricData(metric);

      if (this.canSendMetric()) {
        return sparkInstance.metrics
          .submitClientMetrics(`${NS}${resource}`, formattedData);
      }
      return props.addToQueue(metric);
    }

    @autobind
    sendSavedMetric(metricName) {
      const props = this.props;
      const {
        metricsStore
      } = props;
      const metric = metricsStore.getIn([`items`, metricName]);

      if (metric) {
        return this.sendMetric(metric)
          .then(() => props.deleteMetric(metricName));
      }
      return false;
    }

    @autobind
    sendQueue() {
      const {
        canSendMetric,
        hasQueuedMetrics,
        sendMetric,
        props
      } = this;
      const {
        metricsStore
      } = props;

      if (canSendMetric() && hasQueuedMetrics() && !metricsStore.getIn([`status`, `isSendingQueue`])) {
        props.updateMetricsStatus({isSendingQueue: true});
        return Promise.all(
          metricsStore.get(`queue`)
            .map((metric) => sendMetric(metric))
          )
          .then(() => {
            props.clearQueue();
            return props.updateMetricsStatus({isSendingQueue: false});
          });
      }
      return Promise.resolve();
    }

    @autobind
    sendStartMetric(metric) {
      const computedMetric = Object.assign({}, {
        action: `start`,
        data: window.performance.now()
      }, metric);
      const metricName = [metric.resource, metric.event, `start`].join(`:`);

      this.props.storeMetric(metricName, computedMetric);
      return this.sendMetric(computedMetric);
    }

    @autobind
    sendEndMetric(metric) {
      // Grab end timestamp and send
      const end = window.performance.now();
      const endMetric = Object.assign({}, {
        action: `end`,
        data: end
      }, metric);
      const sendEnd = this.sendMetric(endMetric);
      let sendDuration = Promise.resolve();
      // Check for starting time
      const startName = [metric.resource, metric.event, `start`].join(`:`);
      const start = this.props.metricsStore.getIn([`items`, startName, `data`]);
      if (start) {
        const durationMetric = Object.assign({}, {
          action: `duration`,
          data: end - start
        }, metric);
        sendDuration = this.sendMetric(durationMetric);
        this.props.deleteMetric(startName);
      }

      return Promise.all([sendEnd, sendDuration]);
    }


    formatMetricData({data, action, event, fields, tags}) {
      return {
        type: [`operational`],
        tags: Object.assign({
          action,
          event
        }, tags),
        fields: Object.assign(defaultFields, {
          data
        }, fields)
      };
    }

    render() {
      const {
        sendQueue,
        sendMetric,
        sendStartMetric,
        sendEndMetric
      } = this;

      const metrics = {
        sendQueue,
        sendMetric,
        sendStartMetric,
        sendEndMetric
      };

      // Try to send queue on every load if there is something to send
      sendQueue();

      return <WrappedComponent {...this.props} metrics={metrics} />;
    }
  }

  const injectedProps = {
    sparkInstance: PropTypes.object,
    metricsStore: PropTypes.object,
    updateMetricsStatus: PropTypes.func,
    deleteMetric: PropTypes.func,
    storeMetric: PropTypes.func,
    addToQueue: PropTypes.func,
    clearQueue: PropTypes.func
  };

  InjectSparkMetrics.propTypes = {
    startTime: PropTypes.number,
    ...injectedProps
  };

  InjectSparkMetrics.defaultProps = {
    startTime
  };

  InjectSparkMetrics.displayName = `InjectSparkMetrics(${getDisplayName(WrappedComponent)})`;
  InjectSparkMetrics.WrappedComponent = WrappedComponent;

  return connect(
    (state) => ({
      metricsStore: state.metricsStore,
      sparkInstance: state.spark.get(`spark`),
      sparkState: state.spark.get(`status`)
    }),
    (dispatch) => bindActionCreators({
      deleteMetric,
      storeMetric,
      addToQueue,
      clearQueue,
      updateMetricsStatus
    }, dispatch)
  )(InjectSparkMetrics);
}

function getDisplayName(C) {
  return C.displayName || C.name || `C`;
}
