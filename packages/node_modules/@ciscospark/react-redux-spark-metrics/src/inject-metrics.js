import React, {Component, PropTypes} from 'react';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import autobind from 'autobind-decorator';

import {
  deleteMetric,
  storeMetric,
  addToQueue,
  clearQueue
} from './actions';

const NS = `ciscospark-widget-`;

export default function injectSparkMetrics(WrappedComponent) {
  const defaultFields = {
    protocol: window.location.protocol,
    hostname: window.location.hostname,
    pathname: window.location.pathname,
    widgetVersion: process.env.REACT_CISCOSPARK_VERSION,
    iteration: 0
  };

  class InjectSparkMetrics extends Component {
    shouldComponentUpdate() {
      return true;
    }

    @autobind
    canSendMetric() {
      const {
        sparkInstance,
        sparkState
      } = this.props;
      return sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`);
    }

    @autobind
    hasQueuedMetrics() {
      const {
        metricsStore
      } = this.props;
      return metricsStore && metricsStore.get(`queue`).count();
    }


    @autobind
    sendMetric(metric) {
      const {props} = this;
      const {sparkInstance} = props;
      const {
        resource
      } = metric;
      const formattedData = this.formatMetricData(metric);

      if (this.canSendMetric()) {
        return sparkInstance.metrics
          .submitClientMetrics(`${NS}${resource}`, formattedData);
      }
      return props.addToQueue(resource, formattedData);
    }

    @autobind
    sendSavedMetric(metricName) {
      const props = this.props;
      const {
        metricsStore,
        sparkInstance
      } = props;
      const metric = metricsStore.getIn([`items`, metricName]);

      if (metric) {
        return this.sendMetric(sparkInstance, metric.toJS())
          .then(() => props.deleteMetric(metricName));
      }
      return false;
    }

    @autobind
    sendQueue() {
      const {
        canSendMetric,
        hasQueuedMetrics,
        sendMetric,
        props
      } = this;
      const {
        metricsStore,
        sparkInstance
      } = props;

      if (canSendMetric() && hasQueuedMetrics()) {
        props.updateMetricsStatus({isSendingQueue: true});
        return Promise.all(
          metricsStore.get(`queue`)
            .map((metric) => sendMetric(sparkInstance, metric))
          )
          .then(() => {
            props.clearQueue();
            return props.updateMetricsStatus({isSendingQueue: false});
          });
      }
      return Promise.resolve();
    }

    formatMetricData({data, action, event, fields, tags}) {
      return {
        type: [`operational`],
        tags: Object.assign({
          action,
          event
        }, tags),
        fields: Object.assign(defaultFields, {
          data
        }, fields)
      };
    }

    render() {
      const {
        sendQueue,
        sendMetric
      } = this;

      const metrics = {
        sendQueue,
        sendMetric
      };

      // Try to send queue on every load if there is something to send
      sendQueue();

      return <WrappedComponent {...this.props} metrics={metrics} />;
    }
  }

  const injectedProps = {
    sparkInstance: PropTypes.object,
    metricsStore: PropTypes.object
  };

  InjectSparkMetrics.propTypes = {
    startTime: PropTypes.string,
    ...injectedProps
  };

  InjectSparkMetrics.displayName = `InjectSparkMetrics(${getDisplayName(WrappedComponent)})`;
  InjectSparkMetrics.WrappedComponent = WrappedComponent;

  return connect(
    (state) => ({
      metricsStore: state.metricsStore,
      sparkInstance: state.spark.get(`spark`),
      sparkState: state.spark.get(`status`)
    }),
    (dispatch) => bindActionCreators({
      deleteMetric,
      storeMetric,
      addToQueue,
      clearQueue
    }, dispatch)
  )(InjectSparkMetrics);
}

function getDisplayName(C) {
  return C.displayName || C.name || `C`;
}
