import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {debounce} from 'lodash';

import {
  setUserTyping,
  submitActivity,
  updateActivityText
} from '@ciscospark/redux-module-activity';

import TextArea from '@ciscospark/react-component-textarea';
import FileUploader from '@ciscospark/react-container-file-uploader';

import {blurTextArea, focusTextArea} from './actions';

import styles from './styles.css';

export class MessageComposer extends Component {
  constructor(props) {
    super(props);
    this.timerId = 0;
    this.handleTextChange = this.handleTextChange.bind(this);
    this.handleTextAreaBlur = this.handleTextAreaBlur.bind(this);
    this.handleTextAreaFocus = this.handleTextAreaFocus.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.setUserStartTyping = debounce(this.setUserStartTyping, 500, {leading: true, trailing: false});
    this.setUserTyping = this.setUserTyping.bind(this);
    this.setUserStopTyping = this.setUserStopTyping.bind(this);
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;
    return props.activity !== nextProps.activity || props.placeholder !== nextProps.placeholder;
  }

  handleTextChange(e) {
    const props = this.props;
    props.updateActivityText(e.target.value);
    clearTimeout(this.timerId);
    if (e.target.value === ``) {
      this.setUserTyping(false);
    }
    else {
      if (!props.activity.getIn([`status`, `isTyping`])) {
        this.setUserStartTyping();
      }
      this.timerId = setTimeout(this.setUserStopTyping, 3000);
    }
  }

  setUserTyping(state) {
    const props = this.props;
    const {
      conversation,
      sparkInstance
    } = props;
    props.setUserTyping(state, conversation, sparkInstance);
  }

  setUserStopTyping() {
    this.setUserTyping(false);
  }

  setUserStartTyping() {
    this.setUserTyping(true);
  }


  handleKeyDown(e) {
    if (e.keyCode === 13 && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey) {
      this.handleSubmit();
      e.preventDefault();
    }
  }

  handleSubmit() {
    const props = this.props;
    const {
      activity,
      conversation,
      sparkInstance,
      user
    } = props;
    const {onSubmit} = this.props;
    this.setUserTyping(false);
    props.submitActivity(conversation, activity, user.get(`currentUser`), sparkInstance);
    if (onSubmit) {
      onSubmit();
    }
  }

  handleTextAreaBlur() {
    const props = this.props;
    const {
      conversation,
      sparkInstance
    } = props;
    props.blurTextArea();
    props.setUserTyping(false, conversation, sparkInstance);
  }

  handleTextAreaFocus() {
    const props = this.props;
    props.focusTextArea();
  }

  render() {
    let text;
    const props = this.props;
    if (props.activity && props.activity.has(`text`)) {
      text = props.activity.get(`text`);
    }
    const {placeholder} = this.props;
    const textAreaFocusStyle = props.messageComposer.getIn([`status`, `hasTextAreaFocus`]) ? styles.hasFocus : ``;

    return (
      <div className={classNames(`ciscospark-message-composer`, styles.messageComposer, textAreaFocusStyle)}>
        <FileUploader onSubmit={this.handleSubmit} />
        <div className={classNames(`ciscospark-textarea-container`, styles.textareaContainer)}>
          <TextArea
            onBlur={this.handleTextAreaBlur}
            onChange={this.handleTextChange}
            onFocus={this.handleTextAreaFocus}
            onKeyDown={this.handleKeyDown}
            onSubmit={this.handleSubmit}
            placeholder={placeholder}
            rows={1}
            textAreaClassName={styles.textarea}
            value={text}
          />
        </div>
      </div>
    );
  }
}

MessageComposer.propTypes = {
  onSubmit: PropTypes.func,
  placeholder: PropTypes.string
};

function mapStateToProps(state, ownProps) {
  return {
    activity: state.activity,
    conversation: state.conversation,
    sparkInstance: ownProps.sparkInstance || state.spark.get(`spark`),
    user: state.user,
    messageComposer: state.messageComposer
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    blurTextArea,
    focusTextArea,
    setUserTyping,
    submitActivity,
    updateActivityText
  }, dispatch)
)(MessageComposer);
