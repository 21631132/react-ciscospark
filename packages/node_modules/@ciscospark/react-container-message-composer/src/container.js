import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {debounce} from 'lodash';
import {autobind} from 'core-decorators';

import {
  MentionsInput,
  Mention
} from 'react-mentions';

import {
  setUserTyping,
  submitActivity,
  storeActivityText
} from '@ciscospark/redux-module-activity';

import {searchForUser} from '@ciscospark/redux-module-search';
import TextArea from '@ciscospark/react-component-textarea';
import Avatar from '@ciscospark/react-component-avatar';
import FileUploader from '@ciscospark/react-container-file-uploader';

import {blurTextArea, focusTextArea} from './actions';

import styles from './styles.css';
import mentionStyles from './mentions.css';

export class MessageComposer extends Component {
  constructor(props) {
    super(props);
    this.timerId = 0;
    this.setUserStartTyping = debounce(this.setUserStartTyping, 500, {leading: true, trailing: false});
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;
    return props.activity !== nextProps.activity || props.placeholder !== nextProps.placeholder;
  }

  @autobind
  handleTextChange(e, newValue, newValuePlainText) {
    const props = this.props;
    let value = e.target.value;
    if (newValue && newValue.length) {
      value = newValue;
    }
    props.storeActivityText(value, newValuePlainText);

    clearTimeout(this.timerId);
    if (value === ``) {
      this.setUserTyping(false);
    }
    else {
      if (!props.activity.getIn([`status`, `isTyping`])) {
        this.setUserStartTyping();
      }
      this.timerId = setTimeout(this.setUserStopTyping, 3000);
    }
  }

  @autobind
  setUserTyping(state) {
    const props = this.props;
    const {
      conversation,
      sparkInstance
    } = props;
    props.setUserTyping(state, conversation, sparkInstance);
  }

  @autobind
  setUserStopTyping() {
    this.setUserTyping(false);
  }

  setUserStartTyping() {
    this.setUserTyping(true);
  }

  @autobind
  handleKeyDown(e) {
    if (e.keyCode === 13 && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey) {
      this.handleSubmit();
      e.preventDefault();
    }
  }

  @autobind
  handleSubmit() {
    const props = this.props;
    const {
      activity,
      conversation,
      sparkInstance,
      user
    } = props;
    const {onSubmit} = this.props;
    this.setUserTyping(false);
    props.submitActivity(conversation, activity, user.get(`currentUser`), sparkInstance);
    if (typeof onSubmit === `function`) {
      onSubmit();
    }
  }

  @autobind
  handleTextAreaBlur() {
    const props = this.props;
    const {
      conversation,
      sparkInstance
    } = props;
    props.blurTextArea();
    props.setUserTyping(false, conversation, sparkInstance);
  }

  @autobind
  handleTextAreaFocus() {
    const props = this.props;
    props.focusTextArea();
  }

  @autobind
  searchForMention(term) {
    const {
      avatar,
      conversation,
      user
    } = this.props;

    const participants = [];
    conversation.get(`participants`).toJS().forEach((p) => {
      if (user.get(`currentUser`).id !== p.id) {
        participants.push({
          display: p.displayName,
          id: p.id,
          avatarUrl: avatar.getIn([`items`, p.id])
        });
      }
    });

    if (term) {
      return participants.filter((p) => p.display.toLowerCase().includes(term.toLowerCase()));
    }
    return participants;
  }

  renderSuggestion(entry, search, highlightedDisplay) {
    return (
      <div className={mentionStyles.content}>
        <div className={mentionStyles.avatar}>
          <Avatar image={entry.avatarUrl} name={entry.display} size="medium" />
        </div>
        <div className={mentionStyles.highlightedDisplay}>
          {highlightedDisplay}
        </div>
      </div>
    );
  }

  render() {
    let text;
    const props = this.props;
    if (props.activity && props.activity.has(`text`)) {
      text = props.activity.get(`text`);
    }
    const {
      placeholder,
      conversation
    } = this.props;
    const textAreaFocusStyle = props.messageComposer.getIn([`status`, `hasTextAreaFocus`]) ? styles.hasFocus : ``;
    const mentionMarkup = `@{__display__}|__id__|`;

    // Only show mentions if this is not a one on one convo
    const showMentions = props.showMentions && !conversation.getIn([`status`, `isOneOnOne`]);

    return (
      <div className={classNames(`ciscospark-message-composer`, styles.messageComposer, textAreaFocusStyle)}>
        <FileUploader onSubmit={this.handleSubmit} />
        <div className={classNames(`ciscospark-textarea-container`, styles.textareaContainer)}>
          {
            showMentions &&
            <MentionsInput
              classNames={mentionStyles} // eslint-disable-line react/forbid-component-props
              markup={mentionMarkup}
              onBlur={this.handleTextAreaBlur}
              onChange={this.handleTextChange}
              onFocus={this.handleTextAreaFocus}
              onKeyDown={this.handleKeyDown}
              onSubmit={this.handleSubmit}
              placeholder={placeholder}
              rows={1}
              value={text}
            >
              <Mention
                className={mentionStyles.mentions__mention} // eslint-disable-line react/forbid-component-props
                data={this.searchForMention}
                renderSuggestion={this.renderSuggestion}
                trigger="@"
              />
            </MentionsInput>
          }
          {
            !showMentions &&
            <TextArea
              onBlur={this.handleTextAreaBlur}
              onChange={this.handleTextChange}
              onFocus={this.handleTextAreaFocus}
              onKeyDown={this.handleKeyDown}
              onSubmit={this.handleSubmit}
              placeholder={placeholder}
              rows={1}
              textAreaClassName={styles.textarea}
              value={text}
            />
          }
        </div>
      </div>
    );
  }
}

const injectedPropTypes = {
  searchForUser: PropTypes.func
};

MessageComposer.propTypes = {
  onSubmit: PropTypes.func,
  placeholder: PropTypes.string,
  showMentions: PropTypes.bool,
  ...injectedPropTypes
};

function mapStateToProps(state, ownProps) {
  return {
    activity: state.activity,
    avatar: state.avatar,
    conversation: state.conversation,
    sparkInstance: ownProps.sparkInstance || state.spark.get(`spark`),
    user: state.user,
    messageComposer: state.messageComposer
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    blurTextArea,
    focusTextArea,
    setUserTyping,
    submitActivity,
    searchForUser,
    storeActivityText
  }, dispatch)
)(MessageComposer);
