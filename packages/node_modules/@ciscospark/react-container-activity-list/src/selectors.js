// eslint-disable-reason combining lots of items from store
/* eslint-disable max-params */
import {createSelector} from 'reselect';
import moment from 'moment';
import {filterSync} from '@ciscospark/helper-html';

import defaultFormatters from './formatters';

import {
  ITEM_TYPE_ACTIVITY,
  ITEM_TYPE_DAY_SEPARATOR,
  ITEM_TYPE_NEW_MESSAGE_SEPARATOR
} from '@ciscospark/react-component-activity-list';

const getConversationActivities = (state) => state.conversation.get('activities');
const getConversationTypeOneOnOne = (state) => state.conversation.getIn(['status', 'isOneOnOne']);
const getAvatar = (state) => state.avatar;
const getUser = (state) => state.user;
const getFlags = (state) => state.flags.get('flags');
const getSendingActivities = (state) => state.activity;
const getActivityFormatter = (state, props) => props.activityFormatter;
const getLastAcknowledgedActivityId = (state) => state.conversation.get('lastAcknowledgedActivityId');
const getOnEvent = (state, props) => props.onEvent;

const VISIBLE_ACTIVITY_VERBS = {
  tombstone: {},
  share: {
    objectTypes: ['content']
  },
  post: {
    objectTypes: ['comment']
  },
  create: {
    objectTypes: ['conversation']
  },
  update: {
    objectTypes: ['locusSessionSummaryParticipant', 'locusSessionSummary']
  },
  add: {
    objectTypes: ['person']
  },
  leave: {
    objectTypes: ['person']
  }
};


/**
 * This loops through our conversation activities and computes an array
 * of 'visible activities' to be used with the ActivityList component
 */
export const getActivityList = createSelector(
  [
    getConversationActivities,
    getAvatar,
    getUser,
    getSendingActivities,
    getFlags,
    getLastAcknowledgedActivityId,
    getActivityFormatter,
    getOnEvent,
    getConversationTypeOneOnOne
  ],
  (
    conversationActivities,
    avatar,
    user,
    sendingActivities,
    flags,
    lastAcknowledgedActivityId,
    activityFormatter,
    onEvent,
    conversationIsOneOnOne
  ) => {
    const avatars = avatar.get('items');
    const currentUser = user.get('currentUser');
    const inFlightActivities = sendingActivities.get('inFlightActivities');
    const activityFailures = sendingActivities.get('activityFailures');
    const visibleActivityList = [];
    const now = moment();
    let lastActorId, lastDay, lastVerb;
    let shouldDisplayNewMessageMarker = false;

    conversationActivities.forEach((activity) => { // eslint-disable-line complexity
      if (isActivityVisible(activity)) {
        // Insert day separator if this activity and last one happen on a different day
        const activityMoment = moment(activity.published, moment.ISO_8601);
        const activityDay = activityMoment.endOf('day');
        const sameDay = activityDay.diff(lastDay, 'days') === 0;
        if (lastDay && !sameDay) {
          visibleActivityList.push({
            type: ITEM_TYPE_DAY_SEPARATOR,
            fromDate: lastDay,
            key: `day-separtor-${activity.id}`,
            now,
            toDate: activityDay
          });
        }
        lastDay = activityDay;

        // New message marker
        if (shouldDisplayNewMessageMarker) {
          visibleActivityList.push({
            type: ITEM_TYPE_NEW_MESSAGE_SEPARATOR,
            key: `new-messages-${activity.id}`
          });
          shouldDisplayNewMessageMarker = false;
        }

        // Actual visible activity item
        // additional items don't repeat user avatar and name
        const isAdditional = sameDay && lastActorId === activity.actor.id && lastVerb === activity.verb;
        lastActorId = activity.actor.id;
        lastVerb = activity.verb;

        // eslint-disable-reason callbacks are necessary
        // eslint-disable-next-line max-nested-callbacks
        const isFlagged = !!flags.count() && flags.some((flag) => flag.get('activityUrl') === activity.url);
        // Update verbs are currently used for call data
        let callData;
        if (activity.verb === 'update') {
          callData = getCallData(activity, currentUser, conversationIsOneOnOne);
        }

        let formattedActivity = activity;
        if (activity.verb === 'post') {
          formattedActivity = Object.assign({}, activity, {
            object: formatActivity(activity.object, activityFormatter, onEvent)
          });
        }

        // Name of the user
        let name = activity.actor.displayName;
        if (activity.verb === 'add' || activity.verb === 'leave') {
          name = activity.object.displayName;
        }

        const visibleActivity = {
          type: ITEM_TYPE_ACTIVITY,
          activity: {
            ...formattedActivity,
            callData
          },
          avatarUrl: avatars.get(activity.actor.id),
          isAdditional,
          isFlagged,
          isSelf: currentUser.id === activity.actor.id,
          name
        };

        visibleActivityList.push(visibleActivity);

        // Check if this is the last read activity
        const isLastAcked = lastAcknowledgedActivityId && lastAcknowledgedActivityId === activity.id;
        const isNotSelf = currentUser.id !== activity.actor.id;
        if (isLastAcked && isNotSelf) {
          shouldDisplayNewMessageMarker = true;
        }
      }
    });

    // Create a "fake" activity to display in flight activities
    inFlightActivities.forEach((inFlightActivity) => {
      visibleActivityList.push({
        type: ITEM_TYPE_ACTIVITY,
        activity: inFlightActivity,
        avatarUrl: avatars.get(currentUser.id),
        isAdditional: false,
        isFlagged: false,
        isSelf: true,
        isPending: true
      });
    });

    // Create a "fake" activity to display failed activities
    activityFailures.forEach((activityFailure) => {
      visibleActivityList.push({
        type: ITEM_TYPE_ACTIVITY,
        activity: activityFailure,
        avatarUrl: avatars.get(currentUser.id),
        isAdditional: false,
        hasError: true,
        isFlagged: false,
        isSelf: true,
        isPending: true
      });
    });

    return visibleActivityList;
  }
);

/**
 * Applies additional formatting to activity
 *
 * @export
 * @param {Object} activityObject
 * @returns {Object}
 */

export function formatActivity(activity, activityFormatter, onEvent) {
  const activityObject = filterActivity(activity);

  if (typeof activityFormatter === 'function') {
    return activityFormatter(activityObject, defaultFormatters, onEvent);
  }
  return defaultFormatters(activityObject, onEvent);
}

/**
 * Applies safe filters activity content
 *
 * @param {Object} activityObject raw activity.object
 * @returns {Object}
 */

export function filterActivity(activityObject) {
  const outputActivity = Object.assign({}, activityObject);
  if (outputActivity.content) {
    outputActivity.content = filterSync(() => {}, { // eslint-disable-line no-empty-function
      'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
      a: ['href'],
      b: [],
      blockquote: ['class'],
      strong: [],
      i: [],
      em: [],
      pre: [],
      code: ['class'],
      br: [],
      hr: [],
      p: [],
      ul: [],
      ol: [],
      li: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: []
    }, [], outputActivity.content);
  }
  return outputActivity;
}


/**
 * Determines if an activity object is a visible activity
 * @param {object} activity
 * @returns {bool}
 */
function isActivityVisible(activity) {
  if (!VISIBLE_ACTIVITY_VERBS.hasOwnProperty(activity.verb)) {
    return false;
  }
  const verb = VISIBLE_ACTIVITY_VERBS[activity.verb];
  if (verb.objectTypes) {
    if (verb.objectTypes.indexOf(activity.object.objectType) === -1) {
      return false;
    }
  }
  return true;
}

/**
 * Parses call data from an activity
 * @param {object} activity
 * @param {object} currentUser
 * @param {boolean} conversationIsOneOnOne
 * @returns {object}
 */
function getCallData(activity, currentUser, conversationIsOneOnOne) {
  if (activity.object.objectType !== 'locusSessionSummary') {
    return null;
  }
  // Call/Meeting update parsing
  const callObject = activity.object;
  const partner = callObject.participants.items.find((p) => p.person.entryUUID !== currentUser.id);
  const me = callObject.participants.items.find((p) => p.person.entryUUID === currentUser.id);

  const iWasJoined = me && me.state === 'LEFT';
  const iDeclined = me && me.state === 'DECLINED';
  const everyBodyJoined = callObject.participants.items.every((p) => p.state === 'LEFT');

  const callees = callObject.participants.items.filter((p) => !p.isInitiator);
  const noBodyJoined = callees.every((p) => p.state !== 'LEFT');

  const actorWasMe = activity.actor.entryUUID === currentUser.id;

  const {arg, status} = conversationIsOneOnOne
    ? getCallDataOneOnOne(everyBodyJoined, iDeclined, actorWasMe, partner)
    : getCallDataGroup(iWasJoined, noBodyJoined, actorWasMe, activity);

  // Duration
  const duration = moment.duration((callObject.duration || 0) * 1000).humanize();

  return {
    callInfo: {
      duration,
      ...arg
    },
    status
  };
}

function getCallDataOneOnOne(everyBodyJoined, iDeclined, actorWasMe, partner) {
  let arg, status;
  if (everyBodyJoined) {
    status = 'youHadACall';
  }
  // One on One Call
  else if (iDeclined) {
    status = 'youCancelledACall';
  }
  else if (actorWasMe) {
    status = 'someoneWasUnavailable';
    arg = {name: partner.person.displayName};
  }
  else {
    status = 'youMissedACall';
  }
  return {arg, status};
}

function getCallDataGroup(iWasJoined, noBodyJoined, actorWasMe, activity) {
  let arg, status;
  if (iWasJoined && !noBodyJoined) {
    status = 'youHadAMeeting';
  }
  else if (noBodyJoined) {
    if (actorWasMe) {
      status = 'nobodyJoinedYourMeeting';
    }
    else {
      status = 'nobodyJoinedTheMeeting';
    }
    arg = {name: activity.actor.displayName};
  }
  else {
    status = 'youMissedAMeeting';
  }
  return {arg, status};
}
